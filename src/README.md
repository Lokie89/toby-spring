#### 1-1 초난감 DAO
###### 코드 추가
    1. add, get 두개의 메소드 생성
    2. add, get 메소드를 검증하기 위한 테스트 코드 작성
###### gradle 추가    
    mysql 연결
    compile group: 'mysql', name: 'mysql-connector-java', version: '8.0.15'
###### 문제점
    Windows Intellij 콘솔 창에 한글이 깨져서 나옴
        - JetBrains / bin / vm.options 파일 둘다 -Dfile.encoding=UTF-8 추가
        - intellij settings / File Encodings 세 항목 UTF-8로 변경
        - intellij settings / Edit Custom VM options -Dfile.encoding=UTF-8 추가
        - 재부팅
###### 정리
    코드의 기능을 검증하고자 할 때는 오브젝트 스스로 자신을 검증하도록 만들기
    
#### 1-2 DAO 의 분리
###### 코드 추가
    1. Connection 을 가져오는 중복된 코드 분리
    2. Connection 을 상속을 통해 서브클래스로 분리
    3. UserDao 의 getConnection() 기능을 확장
###### 문제점
    상속을 통해 관심이 다른 기능을 분리하고, 필요에 따라 다양한 변신이 가능하도록
    확장성도 줬지만 여전히 상속관계는 두 가지 다른 관심사에대해 긴밀한 결합을 허용한다.
    슈퍼클래스의 내부 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있음.
###### 정리
    개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 
    "미래의 변화를 어떻게 대비" 할 것인가.
    분리와 확장을 고려한 설계
    
    관심사의 분리
        관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고,
        관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리
    
    템플릿 메소드 패턴
        슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를
        추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤
        서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용
    
    팩토리 메소드 패턴
        서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것

#### 1-3 DAO 의 확장
###### 코드 추가
    1. Connection 을 가져오는 독립적 클래스 SimpleConnectionMaker 추가
        - N사와 D 사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션 기능 사용 불가능
    2. 인터페이스 도입 ConnectionMaker 추가
    3. ConnectionMaker 구현 NConnectionMaker, DConnectionMaker 클래스 추가
        ( 2 - 3 전략패턴 적용 )
    4. UserDao 에 ConnectionMaker 필드 추가, 생성자 주입
    5. 클라이언트 ( UserDaoTest ) ConnectionMaker 생성 후 주입
###### 문제점 
    어떤 ConnectionMaker 구현체를 사용할 것인지를 결정하는 기능을 UserDaoTest 에서 가지고 있음
###### 정리
    클래스 사이의 의존 관계는 만들지 말고,
    오브젝트 사이의 다이나믹한 의존 관계를 만들어라.
    
    개방 폐쇄 원칙
        클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
        
    높은 응집도와 낮은 결합도
        응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것
        결합도가 낮다는 것은 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는
        다른 오브젝트에게 변화를 요구하는 정도가 낮다는 것
        
    전략 패턴
        자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해
        외부에 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라
        바꿔서 사용할 수 있게 하는 디자인 패턴
#### 1-4 제어의 역전 ( IoC )
###### 코드 추가
    1. UserDao 생성 책임을 갖는 DaoFactory 클래스
###### 정리
    팩토리
        객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것
        오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과
        책임을 깔끔하게 분리하려는 목적
        
    제어의 역전 
        프로그램의 제어 흐름 구조가 뒤바뀌는 것
        제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않음
        생성하지도 않음, 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없음
        모든 제어 권한을 자신이 아닌 다른 대상에게 위임

#### 1-5 스프링의 IoC
###### 코드 추가
    1. DaoFactory class @Configuration 등록
    2. DaoFactory class userDao, connectionMaker @Bean 등록
    3. UserDaoTest ApplicationContext 에서 위에서 등록한 userDao 추출 (getBean())
###### gradle 추가
    compile group: 'org.springframework', name: 'spring-core', version: '5.2.4.RELEASE'
    @Configuration, @Bean, ApplicationContext 사용
    compile group: 'org.springframework', name: 'spring-context', version: '5.2.4.RELEASE'
###### 정리
    빈
        스프링이 직접 IoC 방식으로 생성과 제어를 관리하는 오브젝트
    빈 팩토리
        스프링의 IoC 를 담당하는 핵심 컨테이너
    애플리케이션 컨텍스트
        빈 팩토리에 스프링이 제공하는 각종 부가 서비스를 추가로 제공하는 IoC 컨테이너
    설정정보
        애플리케이션 컨텍스트가 IoC 를 적용하기 위해 사용하는 메타정보

#### 1-6 싱글톤 레지스트리와 오브젝트 스코프
###### 정리
    ApplicationContext 에서 getBean() 을 호출하여 얻은 오브젝트는 동일하다.
    
    대규모의 엔터프라이즈 서버 환경에서 수십 수백번씩 브라우저나 다른 시스템으로부터
    요청을 받아 처리하기 위해서 매번 새로운 오브젝트를 만들면 서버에 과부하가 걸린다.
    그래서 클래스당 하나의 오브젝트만 만들어 두고 사용자의 요청을 담당하는 여러 스레드에서
    하나의 오브젝트를 공유해 동시에 사용한다.
    
    이런 디자인 패턴을 싱글톤 패턴이라 하는데, 이 디자인 패턴에는 한계점이 있다.
    1. private 생성자를 갖고 있기 때문에 상속이 불가능하다.
    2. 테스트하기 어렵다.
    3. 클래스 로더를 어떻게 구성하고 있느냐에 따라서 하나 이상의 오브젝트가 만들어질수 있다.
    4. 어떤 클라이언트가 사용할지 모르기때문에 대부분 전역 상태로 사용된다.
    
    스프링은 서버환경에서 싱글톤이 만들어져 서비스를 제공하는 것은 지지하지만,
    자바의 기본적인 싱글톤 패턴 구형 방식은 위처럼 여러가지 단점이 있기 때문에
    직접 싱글톤 형태의 오브젝트를 만들고 관리하는 "싱글톤 레지스트리" 라는 기능을 제공한다.
    
    싱글톤 레지스트리는 오브젝트 생성에 관한 모든 권한을 가진 애플리케이션 컨텍스트 덕분에
    private 생성자가 아닌 평범한 자바클래스를 싱글톤으로 활용할 수 있게 해준다.
    
    멀티 스레드 환경에서 주의할 점
    싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는
    상태정보를 내부에 갖고 있지 않은 "무상태 방식"으로 만들어져야 한다.
    
    스코프
        스프링이 관리하는 빈이 생성되고 존재하고 적용되는 범위
        
    싱글톤 스코프 : 컨테이너 내에 한 개의 오브젝트만 만들어짐
    프로토타입 스코프 : 빈을 요청할 때마다 새로운 오브젝트를 만들어줌
    요청 스코프 : 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성
    세션 스코프 : 웹의 세션과 스코프가 유사함

#### 1-7 의존관계 주입 ( DI )
###### 코드 추가
    1. ConnectionMaker 생성 될 때마다 카운팅 해주는 CountingConnectionMaker 추가
    2. CountingConnectionMaker 를 UserDao 에 DI 해주는 CountingDaoFactory 추가
    3. 의존관계 검색을 이용한 UserDaoCountingConnectionTest 추가  
###### 정리
    의존한다는 건 의존 대상, 즉 오브젝트가 변하면 다른 오브젝트에 영향을 끼친다는 것
    
    인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는
    느슨해지면서 변화에 영향을 덜 받는 상태가 됨
    
    인터페이스를 통하여 의존관계 성립, 즉 런타임 시점의 의존관계를 결정하고 만들려면
    제3의 존재가 필요함
    
    의존관계 검색 ( ApplicationContext getBean() ) 과 
    의존관계 주입 ( 외부에서 오브젝트를 주입 ) 의 차이점
    의존관계 검색 방식에서는 검색하는 오브젝트 자신이 스프링의 빈 일 필요가 없다.
    의존관계 주입 방식에서는 검색하는 오브젝트 자신이 스프링의 빈 이어야만 한다.
    오브젝트를 주입해주려면 생성과 초기화 권한을 갖고 있어야 하기 때문
    
    의존관계 주입의 장점은 관심사의 분리를 통해 얻어지는 높은 응집도에서 나온다
      
#### 1-1
###### 코드 추가
###### gradle 추가
###### 문제점
###### 정리

