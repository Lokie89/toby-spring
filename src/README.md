#### 1-1 초난감 DAO
###### 코드 추가
    1. add, get 두개의 메소드 생성
    2. add, get 메소드를 검증하기 위한 테스트 코드 작성
###### gradle 추가    
    mysql 연결
    compile group: 'mysql', name: 'mysql-connector-java', version: '8.0.15'
###### 문제점
    Windows Intellij 콘솔 창에 한글이 깨져서 나옴
        - JetBrains / bin / vm.options 파일 둘다 -Dfile.encoding=UTF-8 추가
        - intellij settings / File Encodings 세 항목 UTF-8로 변경
        - intellij settings / Edit Custom VM options -Dfile.encoding=UTF-8 추가
        - 재부팅
###### 정리
    코드의 기능을 검증하고자 할 때는 오브젝트 스스로 자신을 검증하도록 만들기
    
#### 1-2 DAO 의 분리
###### 코드 추가
    1. Connection 을 가져오는 중복된 코드 분리
    2. Connection 을 상속을 통해 서브클래스로 분리
    3. UserDao 의 getConnection() 기능을 확장
###### 문제점
    상속을 통해 관심이 다른 기능을 분리하고, 필요에 따라 다양한 변신이 가능하도록
    확장성도 줬지만 여전히 상속관계는 두 가지 다른 관심사에대해 긴밀한 결합을 허용한다.
    슈퍼클래스의 내부 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있음.
###### 정리
    개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 
    "미래의 변화를 어떻게 대비" 할 것인가.
    분리와 확장을 고려한 설계
    
    관심사의 분리
        관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고,
        관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리
    
    템플릿 메소드 패턴
        슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를
        추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤
        서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용
    
    팩토리 메소드 패턴
        서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것

#### 1-3 DAO 의 확장
###### 코드 추가
    1. Connection 을 가져오는 독립적 클래스 SimpleConnectionMaker 추가
        - N사와 D 사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션 기능 사용 불가능
    2. 인터페이스 도입 ConnectionMaker 추가
    3. ConnectionMaker 구현 NConnectionMaker, DConnectionMaker 클래스 추가
        ( 2 - 3 전략패턴 적용 )
    4. UserDao 에 ConnectionMaker 필드 추가, 생성자 주입
    5. 클라이언트 ( UserDaoTest ) ConnectionMaker 생성 후 주입
###### 문제점 
    어떤 ConnectionMaker 구현체를 사용할 것인지를 결정하는 기능을 UserDaoTest 에서 가지고 있음
###### 정리
    클래스 사이의 의존 관계는 만들지 말고,
    오브젝트 사이의 다이나믹한 의존 관계를 만들어라.
    
    개방 폐쇄 원칙
        클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
        
    높은 응집도와 낮은 결합도
        응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것
        결합도가 낮다는 것은 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는
        다른 오브젝트에게 변화를 요구하는 정도가 낮다는 것
        
    전략 패턴
        자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해
        외부에 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라
        바꿔서 사용할 수 있게 하는 디자인 패턴
#### 1-4 제어의 역전 ( IoC )
###### 코드 추가
    1. UserDao 생성 책임을 갖는 DaoFactory 클래스
###### 정리
    팩토리
        객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것
        오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과
        책임을 깔끔하게 분리하려는 목적
        
    제어의 역전 
        프로그램의 제어 흐름 구조가 뒤바뀌는 것
        제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않음
        생성하지도 않음, 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없음
        모든 제어 권한을 자신이 아닌 다른 대상에게 위임

#### 1-5 스프링의 IoC
###### 코드 추가
    1. DaoFactory class @Configuration 등록
    2. DaoFactory class userDaoJdbc, connectionMaker @Bean 등록
    3. UserDaoTest ApplicationContext 에서 위에서 등록한 userDaoJdbc 추출 (getBean())
###### gradle 추가
    compile group: 'org.springframework', name: 'spring-core', version: '5.2.4.RELEASE'
    @Configuration, @Bean, ApplicationContext 사용
    compile group: 'org.springframework', name: 'spring-context', version: '5.2.4.RELEASE'
###### 정리
    빈
        스프링이 직접 IoC 방식으로 생성과 제어를 관리하는 오브젝트
    빈 팩토리
        스프링의 IoC 를 담당하는 핵심 컨테이너
    애플리케이션 컨텍스트
        빈 팩토리에 스프링이 제공하는 각종 부가 서비스를 추가로 제공하는 IoC 컨테이너
    설정정보
        애플리케이션 컨텍스트가 IoC 를 적용하기 위해 사용하는 메타정보

#### 1-6 싱글톤 레지스트리와 오브젝트 스코프
###### 정리
    ApplicationContext 에서 getBean() 을 호출하여 얻은 오브젝트는 동일하다.
    
    대규모의 엔터프라이즈 서버 환경에서 수십 수백번씩 브라우저나 다른 시스템으로부터
    요청을 받아 처리하기 위해서 매번 새로운 오브젝트를 만들면 서버에 과부하가 걸린다.
    그래서 클래스당 하나의 오브젝트만 만들어 두고 사용자의 요청을 담당하는 여러 스레드에서
    하나의 오브젝트를 공유해 동시에 사용한다.
    
    이런 디자인 패턴을 싱글톤 패턴이라 하는데, 이 디자인 패턴에는 한계점이 있다.
    1. private 생성자를 갖고 있기 때문에 상속이 불가능하다.
    2. 테스트하기 어렵다.
    3. 클래스 로더를 어떻게 구성하고 있느냐에 따라서 하나 이상의 오브젝트가 만들어질수 있다.
    4. 어떤 클라이언트가 사용할지 모르기때문에 대부분 전역 상태로 사용된다.
    
    스프링은 서버환경에서 싱글톤이 만들어져 서비스를 제공하는 것은 지지하지만,
    자바의 기본적인 싱글톤 패턴 구형 방식은 위처럼 여러가지 단점이 있기 때문에
    직접 싱글톤 형태의 오브젝트를 만들고 관리하는 "싱글톤 레지스트리" 라는 기능을 제공한다.
    
    싱글톤 레지스트리는 오브젝트 생성에 관한 모든 권한을 가진 애플리케이션 컨텍스트 덕분에
    private 생성자가 아닌 평범한 자바클래스를 싱글톤으로 활용할 수 있게 해준다.
    
    멀티 스레드 환경에서 주의할 점
    싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는
    상태정보를 내부에 갖고 있지 않은 "무상태 방식"으로 만들어져야 한다.
    
    스코프
        스프링이 관리하는 빈이 생성되고 존재하고 적용되는 범위
        
    싱글톤 스코프 : 컨테이너 내에 한 개의 오브젝트만 만들어짐
    프로토타입 스코프 : 빈을 요청할 때마다 새로운 오브젝트를 만들어줌
    요청 스코프 : 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성
    세션 스코프 : 웹의 세션과 스코프가 유사함

#### 1-7 의존관계 주입 ( DI )
###### 코드 추가
    1. ConnectionMaker 생성 될 때마다 카운팅 해주는 CountingConnectionMaker 추가
    2. CountingConnectionMaker 를 UserDao 에 DI 해주는 CountingDaoFactory 추가
    3. 의존관계 검색을 이용한 UserDaoCountingConnectionTest 추가  
###### 정리
    의존한다는 건 의존 대상, 즉 오브젝트가 변하면 다른 오브젝트에 영향을 끼친다는 것
    
    인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는
    느슨해지면서 변화에 영향을 덜 받는 상태가 됨
    
    인터페이스를 통하여 의존관계 성립, 즉 런타임 시점의 의존관계를 결정하고 만들려면
    제3의 존재가 필요함
    
    의존관계 검색 ( ApplicationContext getBean() ) 과 
    의존관계 주입 ( 외부에서 오브젝트를 주입 ) 의 차이점
    의존관계 검색 방식에서는 검색하는 오브젝트 자신이 스프링의 빈 일 필요가 없다.
    의존관계 주입 방식에서는 검색하는 오브젝트 자신이 스프링의 빈 이어야만 한다.
    오브젝트를 주입해주려면 생성과 초기화 권한을 갖고 있어야 하기 때문
    
    의존관계 주입의 장점은 관심사의 분리를 통해 얻어지는 높은 응집도에서 나온다
      
#### 1-8 XML 을 이용한 설정
###### 코드 추가
    1. DaoFactory 를 대체할 applicationContext.xml 파일 추가
    2. UserDao 의존 오브젝트 ConnectionMaker -> DataSource 로 변경
    3. applicationContext.xml 파일의 DataSource 프로퍼티 추가
###### gradle 추가
    SimpleDriverDataSource 사용 ( jdbc 드라이버 클래스, jdbc url, id, pwd 등의 수정자 )
    compile group: 'org.springframework', name: 'spring-jdbc', version: '5.2.4.RELEASE'
###### 정리
    범용 DI 컨테이너를 사용하려면 오브젝트 사이의 의존정보를 일일이 자바 코드로 만들긴 번거롭다.
    스프링은 다양한 방법으로 DI 의존관계 설정정보를 만들 수 있다.
    
    xml 파일에서 DI 의존관계를 설정할 때 사용 하는 <bean> 태그 안에서 property 설정은
    <property> 태그를 통하여 할 수 있음. <property> 태그의 name 애트리뷰트는 DI 에 사용할
    수정자 메소드의 프로퍼티 이름, ref 애트리뷰트는 주입할 오브젝트를 정의한 빈의 id 이다. 

    <property> 태그의 애트리뷰트 중 value 값은 스트링 값을 사용한다.
    그러나 다른 타입의 형태도 주입이 가능한데, 이는 스프링이 프로퍼티의 값을, 
    "수정자 메소드의 파라미터 타입을 참고로 해서 적절한 형태로 변환해주기 때문"

    xml 파일에서 정의한 의존관계 정보를 이용하는 작업에는 GenericXmlApllicationContext 를 사용
    
#### 2-1 UserDaoTest 다시 보기
###### 정리
    테스트는 필수이며 작은 테스트 부터 큰 테스트 까지 모두 해야함
    
#### 2-2 UserDaoTest 개선
###### 코드 추가
    1. UserDaoTest 에서 확인 하는 코드를 단순히 필드를 보여주는 것만이 아닌
       실제 입력했던 필드와 같은 값인지 확인
    2. JUnit 프레임 워크 사용하여 테스트 코드 작성
###### 정리
    테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것
    JUnit 프레임 워크의 조건
        메소드가 public 으로 선언
        메소드에 @Test 라는 어노테이션 붙여줄 것

#### 2-3 개발자를 위한 테스팅 프레임워크 JUnit
###### 코드 추가
    1. UserDao 에 메소드 추가
    2. UserDaoTest 에 추가한 메소드의 테스트 추가
    3. UserDaoTest 에 예외 발생 테스트 추가
    4. UserDaoTest 의 중복 코드 취합 @Before 어노테이션으로 묶음
###### 정리
    테스트하기 전에 테스트 실행에 문제가 되지 않는 상태를 만들어주는 편이 좋다.
    "항상 네거티브 테스트를 먼저 만들어라."
    
    테스트 주도 개발 TDD
    만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록
    테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발방법
    "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다."

    JUnit 테스트 수행 방식
    1. @Test, public, void, no parameter 메소드 찾는다.
    2. 오브젝트를 만든다
    3. @Before가 붙은 메소드 실행
    4. @Test 메소드 호출 테스트 결과 저장
    5. @After가 붙은 메소드 실행
    6. 다른 테스트에 대해 2~5번 반복
    7. 모든 테스트의 결과 리턴
    
    각 테스트를 진행할 때마다 테스트 클래스의 오브젝트를 새로 생성,
    각 테스트가 서로 영향을 주지않고 독립적으로 실행됨을 보장해주기 위함
    
    픽스처
        테스트를 수행하는데 필요한 정보나 오브젝트

#### 2-4 스프링 테스트 적용
###### 코드 추가
    1. UserDaoTest 의 RunWith 파라미터를 SpringJUnit4ClassRunner.class 로 변경
    2. @ContextConfiguration 추가, 파라미터로 applicationContext.xml 지정
    3. ApplicationContext @Autowired 통해 DI
    4. UserDao @Autowired 통해 DI
    5. testtobyspring database 추가
    6. test-applicationContext.xml 추가
    7. UserDaoTest @ContextConfiguration 파라미터 수정
###### gradle 추가
    SpringJUnit4ClassRunner class, @ContextConfiguration
    testCompile group: 'org.springframework', name: 'spring-test', version: '5.2.4.RELEASE'
###### 정리
    스프링 컨테이너에서 생성되는 오브젝트는 싱글톤 방식으로 생성되기 때문에 하나의 어플리케이션 
    컨텍스트가 만들어져 사용된다. 그러나 JUnit 테스트 메소드를 실행 할때마다 생성되는 UserDaoTest의 오브젝트는 
    매번 다른 주소값을 갖는 새로운 테스트 오브젝트를 생성한다.
    
    @Autowired 가 붙은 인스턴스 변수가 있으면, 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다.
    또, 타입으로 가져올 빈 하나를 선택할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다.
    변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.
    
    DI 를 적용할 때 인터페이스를 둬야 하는 이유
    1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
       당장 클래스의 변경이 없다고 하더라도 변경이 필요한 상황이 닥쳤을 때 수정에 들어가는 시간과 비용의 부담을 줄일수 있다.
    2. 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면
       다른 차원의 서비스 기능을 도입할 수 있기 때문이다.
       새로운 기능을 넣기 위해 기존 코드는 수정할 필요가 없다.
    3. 테스트 때문이다.
       효율적인 테스트를 손쉽게 만들기 위해서 DI를 적용해야 한다. 
    
    DataSource 같은 경우에는 실제 운영 DB와 개발용 ( TEST ) DB를 다르게 가지고 가는 방법이 좋다.
    따라서 개발용 DB 를 따로 만들고 해당 테스트 클래스 또는 메소드에 @DirtiesContext 를 사용한다.
    
    @DirtiesContext 는 해당 클래스 또는 메소드의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다.
    이 애노테이션이 붙은 테스트 클래스 또는 메소드에는 애플리케이션 컨텍스트 공유를 허용하지 않는다.
    
    @DirtiesContext 사용 후 코드 내에 수동으로 DI 를 설정하는 것보단
    따로 xml 파일을 하나 더 생성해 해당 테스트 클래스에 적용해주는 것이 더 좋은 방법이다.
     
#### 2-5 학습 테스트로 배우는 스프링
###### 코드 추가
    1. JUnit 테스트 시 생성되는 오브젝트에 대한 테스트 추가
###### 정리
    학습테스트
        자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서 테스트를 작성
    장점
    1. 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
    2. 학습 테스트 코드를 개발 중에 참고할 수 있다.
    3. 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
    4. 테스트 작성에 대한 좋은 훈련이 된다.
    5. 새로운 기술을 공부하는 과정이 즐거워진다
    
    버그테스트
        코드에 오류가 있을 때 그 오류를 가장 잘 드러낼줄 수 있는 테스트
    장점
    1. 테스트의 완성도를 높여준다.
    2. 버그의 내용을 명확하게 분석하게 해준다.
    3. 기술적인 문제를 해결하는 데 도움이 된다.    

#### 3-1 다시 보는 초난감 DAO
###### 코드 추가
    1. 예외 발생 시에도 리소스를 반환하도록 UserDao 의 deleteAll 메소드 수정
    2. 위와 같이 UserDao 의 getCount 메소드 수정
###### 정리
    제한적인 리소스를 공유해 사용하는 서버에서 "예외처리"는 지켜야 할 원칙이다.

#### 3-2 변하는 것과 변하지 않는 것
###### 코드 추가
    1. 전략 패턴을 사용하기 위한 StatementStrategy interface 추가
    2. StatementStrategy interface 구현한 DeleteAllStatement class 추가
    3. StatementStrategy interface 를 매개 변수로 받는 
       try catch finally 를 분리한 jdbcContextWithStatementStrategy 메소드 구현
    4. UserDao deleteAll 메소드에서 DeleteAllStatement 객체 생성 후 
       jdbcContextWithStatementStrategy 메소드 사용
###### 정리
    템플릿 메소드 패턴
        상속을 통해 기능을 확장해서 사용함
        변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해 둬서
        서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 함
    
    전략 패턴
        확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임
    
    전략 패턴에 따르면 Context 가 어떤 전략을 사용하게 할 것인가는 Context 를 사용하는
    Client 가 결정하는 게 일반적이다. Client 가 구체적인 전략의 하나를 선택하고 
    오브젝트로 만들어서 Context 에 전달하는 것이다. Context 는 전달받은 
    그 Strategy 구현 클래스의 오브젝트를 사용한다.
    
#### 3-3 JDBC 전략 패턴의 최적화
###### 코드 추가
    1. AddStatement 생성하여 기존 UserDao 의 add() 메소드 변경
###### 문제점
    메소드를 해결하기 위해 클래스를 계속 생성함
    e.g ) add() 를 위해 AddStatement, deleteAll() 을 위해 deleteAllStatement 등
    -> 중첩 클래스 사용
###### 정리
    전략 패턴을 사용하기 위해 전략을 구현한 클래스를 생성하기 위한 팁
    매번 클래스를 생성하는 것은 낭비 and 사용처가 유일함 ( 보통 ) 일때
    중첩 클래스 사용
    
    중첩 클래스
        클래스 내부에 정의되는 클래스를 이야기함
        스태틱 클래스와 내부 클래스로 구분
    
    내부 클래스는 멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 내부 클래스,
    메소드 레벨에서 정의되는 로컬 클래스, 이름을 갖지 않는 익명 내부 클래스로 구분된다.
    
#### 3-4 컨텍스트와 DI
###### 코드 추가
    1. UserDao 의 jdbcContextWithStatementStrategy 를 다른 DAO에서도 사용할 수 있도록 JdbcContext 클래스로 분리
    2. 생성된 JdbcContext 에 DataSource 의존관계 설정
    3. 기존에 UserDao 에서 사용하던 jdbcContextWithStatementStrategy 메서드는 JdbcContext 의 메서드로 대체
###### 문제점
    UserDao 는 인터페이스를 거치지 않고 바로 생성된 JdbcContext 를 사용되고 있다.
    이는 클래스 사이의 의존관계가 성립되지 않도록 하는 기존 DI 와는 다른 의존 방법이다.
###### 정리
    스프링의 DI 는 객체의 생성과 관계설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC 개념을 포괄한다.
    
    JdbcContext 를 UserDao 와 DI 구조로 만들어야 할 이유
        1. JdbcContext 가 스프링 컨테이너의 싱글톤 빈이 되기 때문
        2. JdbcContext 가 DI 를 통해 다른 빈 ( DataSource ) 에 의존하기 있기 때문
    
    그러나 인터페이스를 사용하지 않고 JdbcContext 와 UserDao 의 의존관계를 설정한 이유는
    서로 매우 긴밀한 관계를 가지고 강하게 결합되어 있기 때문
    
    인터페이스를 사용하지 않는 클래스 사이의 의존관계를 갖고 스프링의 DI 를 이용하기 위해 빈으로 등록해서 사용하는 방법은
    오브젝트 사이의 실제 의존관계가 설정파일에 명확하게 드러난다는 장점이 있다. 그러나 DI의 근본적인 원칙에 부합하지 않는
    구체적인 클래스와의 관계가 설정에 직접 노출된다는 단점이 있다.
    
    반면에 수동으로 DI 하는 방법은 클라이언트의 내부에서 만들어지고 사용되면서 그 관계를 외부에는 드러내지 않는다는 장점이 있다.
    그러나 여러 오브젝트가 사용하더라도 싱글톤으로 만들 수 없고, DI 작업을 위한 부가적인 코드가 필요하다는 단점이 있다.
    
    .. 
    인터페이스를 사용하지 않는 클래스 ( 강한 결합 ) 간의 의존관계 적용 시
    스프링 컨테이너를 사용하면 설정 파일에 클래스의 대한 정보가 그대로 드러나지만 스프링 컨테이너가 주는 이점 ( 싱글톤 ) 을 사용할 수 있고,
    스프링 컨테이너를 사용하지 않으면 클라이언트에서 은밀히 그 전략을 외부에 감추고 사용할 수 있지만 스프링 컨테이너의 이점 을 사용할 수 없다.

#### 3-5 템플릿과 콜백
###### 코드 추가
    1. 콜백 메서드의 공통 부분 분리 executeSql 메서드 생성
    2. 다른 DAO 에서도 사용할 수 있도록 executeSql JdbcContext 클래스로 이동
    3. 파라미터가 필요한 메서드를 위해 executeSql 가변인자 추가
    
    템플릿/콜백 패턴 예제
    1. 숫자가 들어있는 txt 파일 추가
    2. txt 파일을 읽어서 계산하는 Calculator 추가
    3. 더하는 calcSum 메소드 추가
    4. 반복되는 로직을 수행하는 LineCallback interface 추가
    5. sum, multiply 로직의 다른 부분을 익명 클래스로 구현 ( 템플릿/콜백 패턴 )
    6. LineCallback 인터페이스에 제네릭스 추가
###### 정리
    템플릿 콜백 패턴
        일정한 패턴을 갖는 작업 흐름이 존재하고, 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 전략패턴을 사용한다.
        전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식을 스프링에서는 템플릿/콜백 패턴이라 한다.
        
    템플릿은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미
    콜백은 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 의미
    
    템플릿/콜백 패턴의 콜백은 보통 단일 메소드를 인터페이스를 사용

#### 3-6 스프링의 JdbcTemplate
###### 코드 추가
    1. UserDao 의 JdbcContext 를 스프링의 JdbcTemplate 으로 대체
    2. JdbcTemplate 의 update, query, queryForObject 를 통하여 각 메서드 로직 대체
###### 정리
    스프링의 제공하는 템플릿/콜백 패턴을 적용하는 클래스 JdbcTemplate
    update :
        PreparedStatementCreator 인터페이스의 구현체를 익명 클래스로 구현하여 매개변수로 넣어줌
        jdbcTemplate 이 가지고 있는 dataSource 으로 만들어진 Connection 을 매개 변수로 갖는 
        createPreparedStatement 메서드 실행
        또는 updatable 문을 매개 변수로 넣어줌
        매개 변수가 필요한 경우 PreparedStatementCreator 구현체 또는 updatable 문 뒤에 차례로 넣어줌
        return 값 없음. 
    query :
        return 값이 필요한 경우,
        PreparedStatementCreator 구현체와, ResultSetExtractor 구현체를 파라미터로 받음
        PreparedStatementCreator 후 나온 결과 값을 ResultSetExtractor 의 extractData 메서드
        파라미터 ResultSet 으로 넘겨줌
    queryForObject :
        query 파라미터 중 ResultSetExtractor 대신 RowMapper 사용
        차이점은 ResultSetExtractor 는 ResultSet 을 한 번 전달받아 추출 작업을 진행하는데 반해
        RowMapper 는 ResultSet 의 로우 하나를 매핑하기 위해 사용되기 때문에 여러번 호출될 수 있다.
        SQL을 실행해서 받은 로우의 개수가 하나가 아니라면 예외를 던진다.

    테스트를 작성할 때 항상 네거티브 테스트부터 만들 것
    
#### 4-1 사라진 SQLException
###### 정리
    예외 처리 문제
        예외가 발생하면 그것을 catch 블록을 써서 잡아내는 것까지는 좋은데 아무것도 하지 않고
        별문제 없는 것처럼 넘어가 버린느건 정말 위험한 일이다.
        모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다.
    
    Error
        시스템에 뭔가 비정상적인 상황이 발생했을 경우 사용된다. 대응방법이 따로 없기 때문에 신경 쓰지 않아도 된다.
    체크 예외
        발생 가능한 예외적인 상황에서 던져질 가능성이 있는 대부분 예외들
        반드시 예외 처리하는 코드를 함께 작성해야 한다. 그렇지 않으면 컴파일 에러가 발생
    언체크 예외 ( RuntimeException )
        주로 프로그램의 오류가 있을 때 발생하도록 의도된 것
        
    예외 처리 방법
        1. 예외 복구
            예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
            try catch
        2. 예외처리 회피
            예외처리를 자신이 담당하지 않고 자신을 호출한 쪽에 던져버리는 것
            throw
        3. 예외 전환
            발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던지는 것
            주로 의미를 분명하게 해줄 수 있는 예외로 바꾸거나, 체크 예외를 언체크 예외로 바꾸는 경우 사용
            catch another exception throw
    
    애플리케이션 예외
        시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고,
        반드시 catch 해서 무엇인가 조치를 취하도록 요구하는 예외
    
    사라진 SQLException
        대부분의 SQLException 은 복구가 불가능하다.
        따라서 스프링의 JdbcTemplate 템플릿과 콜백 안에서 발생하는 모든 SQLException 을 런타임 예외인
        DataAccessException 으로 포장해서 던져주고 있다.
        
#### 4-2 예외 전환
###### 코드 추가
    1. DB에 독립적인 UserDao 생성을 위한 interface 생성 
        ( Jdbc를 사용하는 UserDao 를 UserDaoJdbc 로 변경 UserDao interface 생성 ) 
###### 정리
    DataAccessException 은 SQLException 에 담긴 다루기 힘든 상세한 예외 정보를 의미 있고
    일관성 있는 예외로 전환해서 추상화해주려는 용도로 쓰인다.
    
    JDBC 의 한계
        1. 대부분의 DB는 표준을 따르지 않는 비표준 문법과 기능을 제공한다.
           이에 따라 작성된 비표준 SQL 은 DAO 코드에 들어가고 해당 DAO 는 특정 DB에 종속적인 코드가 되고 만다.
        2. DB 마다 SQL 만 다른 것이 아니라 에러의 종류와 원인도 제각각이다.
           DB 마다 다른 에러 코드를 대신할 수 있도록 XOPEN SQL 스펙에 정의된 SQL 상태 코드를 따르게 되어있지만,
           DB 의 JDBC 드라이버에서 SQLException 에 담을 상태 코드를 정확하게 만들어 주지 않는다.
        따라서 SQLException 에 담긴 SQL 상태 코드는 신뢰할 수 없고, DB 업체별로 만들어 유지해 오고 있는
        DB 전용 에러 코드가 더 정확한 정보
        
    스프링은 이런 JDBC 의 한계를 극복하기 위해 DataAccessException 이라는 런타임 예외를 정의하고
    데이터 엑세스 작업 중에 발생할 수 있는 예외상황을 수십 가지 예외로 분류하고 이를 추상화해 정의한
    다양한 예외 클래스를 제공한다.
    
    스프링에서는 DB 별 에러 코드를 분류해서 스프링이 정의한 예외 클래스와 매핑해놓은
    에러 코드 매핑 정보 테이블을 만들어두고 이를 이용한다.
    
    따라서 JdbcTemplate 을 이용한다면 JDBC에서 발생하는 DB 관련 예외는 거의 신경 쓰지 않아도 된다.
        
#### 5-1 사용자 레벨 관리 기능 추가
###### 코드 추가
    1. 사용자 레벨을 관리할 Level enum 추가
    2. level, login recommend 항목 추가된 테이블에 맞게 메소드 등 변경
    3. UserService 추가
    4. UserServiceTest 추가
    5. UserTest 추가
    6. 업그레이드 정책을 담은 UserLevelUpgradePolicy interface 추가
    7. UserLevelUpgradePolicy 구현 클래스 GeneralUserLevelUpgradePolicy, EventUserLevelUpgradePolicy 추가
###### 정리
    작성된 코드를 살펴볼 때는 다음과 같은 질문을 해본다.
        1. 코드에 중복된 부분은 없는가?
        2. 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
        3. 코드가 자신이 있어야 할 자리에 있는가?
        4. 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

    객체지향적 코드
        내부정보를 다루는 자신의 책임에 충실한 기능을 갖고 있으면서 필요가 생기면 이런 작업을 수행해달라고 서로 요청하는 구조
        각자 자기 책임에 충실한 작업만 하고 있으니 코드를 이해하기도 쉬움
        변경이 필요할 때 어디를 수정해야 할지도 쉽게 알 수 있음
        잘못된 요청이나 작업을 시도했을 때 이를 확인하고 예외를 던져줄 준비도 다 되어 있음
        각각을 독립적으로 테스트하도록 만들면 테스트 코드도 단순해짐
        
        "객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다."
        
        오브젝트에게 데이터를 요구하지 말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이다.
        단순히 '이렇게 만들면 코드를 더 이해하기 쉽고 변화에 대응하기가 편하구나' 라고 생각해도 됨.
        
#### 5-2 트랜잭션 서비스 추상화-1
###### 코드 추가
    1. 트랜잭션 테스트용 UserSrvice 대역 TestUserService 추가
    2. 예외 상황을 위한 TestUserServiceException 추가
    3. UserService upgradeLevels 메서드에 트랜잭션 동기화 적용
###### 정리
    DB 는 그 자체로 완벽한 트랜잭션을 지원한다.
    그러나 다중 SQL 이 사용되는 작업을 하나의 트랜잭션으로 취급해야 하는 경우 트랜잭션으로 묶어야 한다
    
    두 가지 작업이 하나의 트랜잭션이 되려면, 두번째 SQL이 성공적으로 DB 에서 수행되기 전에 문제가 발생할 경우에는
    앞에서 처리한 SQL 작업도 취소 ( 트랜잭션 롤백 )
    반대로 여러 개의 SQL 을 하나의 트랜잭션으로 처리하는 경우에 모든 SQL 수행 작업이 다 성공적으로 마무리 됐다고
    DB 에 알려줘서 작업을 확정 ( 트랜잭션 커밋 )
    
    트랜잭션의 시작을 선언하고 트랜잭션을 종료 ( 롤백 or 커밋 ) 하는 작업을 트랜잭션의 경계 설정 이라고 한다.
    
    여러 번 DB에 업데이트를 해야 하는 작업을 하나의 트랜잭션으로 만들려면
    그 작업이 진행되는 동안 DB 커넥션도 하나만 사용돼야 한다.
    
    트랜잭션 처리를 위해 작업을 진행 하기 전 생성한 Connection 오브젝트를 전달하여 사용할 수 있다.
    그러나 이 방법의 문제점은 
    1. JdbcTemplate 을 더 이상 활용할 수 없다
    2. 트랜잭션 처리할 모든 메서드에 Connection 파라미터가 추가
    3. Connection 파라미터가 인터페이스 메소드에 추가되면 데이터 엑세스 기술에 독립적일 수 없음
    4. 테스트 코드에서도 직접 Connection 오브젝트를 만들어야 함
    등이 생긴다.
    
    그래서 트랜잭션 동기화 방법을 사용한다.
    트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고
    이후에 호출되는 메서드에서는 저장된 Connection 을 가져다가 사용하게 하는 것
    
    스프링의 트랜잭션 동기화
    스프링이 제공하는 트랜잭션 동기화 관리 클래스는 TransactionSynchronizationManager 이며
    1. 이를 이용해 트랜잭션 동기화 작업을 초기화 한다.
    2. DataSourceUtils 에서 제공하는 getConnection() 메서드를 통해 DB 커넥션 생성한다.
       DataSourceUtils 의 getConnection 메서드는 트랜잭션 동기화에 사용하도록 저장소에 바인딩 해줌
    3. 해당 작업을 진행한다.
    4-1. 작업을 정상적으로 마치면 트랜잭션을 커밋한다.
    4-2. 예외가 발생하면 트랜잭션을 롤백한다.
    5. 커넥션을 닫고 동기화 작업을 중단한다.
    
    JdbcTemplate 은 영리하게 동작하도록 설계되어 있어서 트랜잭션이 굳이 필요 없다면 바로 호출해서 사용하고
    트랜잭션을 만들고 이를 관리할 필요가 잇따면 미리 DB 커넥션을 생성한 다음 트랜잭션 동기화를 해주고 사용하면 된다.
     

#### 5-2 트랜잭션 서비스 추상화-2
###### 코드 추가
    1. 스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스 PlatformTransactionManager 사용
    2. PlatformTransactionManager DI 적용
###### 정리
    하나의 트랜잭션 안에서 여러 개의 DB 에 데이터를 넣는 작업을 해야 할 필요가 있을 때
    JDBC 의 Connection 을 이용한 트랜잭션 방식 ( 로컬 트랜잭션 ) 으로는 하나의 DB Connection 에 종속되기 떄문에 불가함
    별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 글로벌 트랜잭션 방식을 사용
    스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공
    PlatformTransactionManager 인터페이스 사용하여
    JTA 는 JTATransactionManager
    Hibernate 는 HibernateTransactionManager
    JPA 는 JPATransactionManager 를 사용하여
    트랜잭션 경계설정을 만듬
    
    어떤 클래스든 스프링의 빈으로 등록할 떄 먼저 검토해야 할 것은 점
    싱글톤으로 만들어져 여러 스레드에서 동시에 사용해도 괜찮은가 하는 가
    

#### 5-3 서비스 추상화와 단일 책임 원칙
###### 정리
    서비스 추상화 수평적 분리
    서로 불필요한 영향을 주지 않으면서 독자적으로 확장 가능하도록 만든 것,
    같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리
    
    서비스 추상화 수직적 분리
    애플리케이션의 비즈니스 로직과 그 하위에서 동작하는 로우레벨의 기술인
    아예 다른 계층의 특성을 갖는 코드를 분리
    
    애플리케이션 로직의 종류에 따른 수평적 구분이든, 로직의 기술에 따른 수직적 구분이든,
    모두 결합도 가 낮으며, 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들수 있는 데는
    스프링의 DI 가 중요한 역할을 하고 있다.
    DI 의 가치는 이렇게 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는 데 있다.
    
    단일 책임 원칙
    하나의 모듈은 한 가지 책임을 가져야 한다.
    하나의 모듈이 바뀌는 이유는 한 가지여야 한다.
    
    단일 책임 원칙을 잘 지키고 있다면, 어떤 변경이 필요할 때 수정 대상이 명확해진다.
    단일 책임 원칙을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 이를 DI 로 연결해야 하며,
    그 결과로 단일 책임 원칙뿐 아니라 개방 폐쇄 원칙도 잘 지켜지고, 모듈 간에 결합도가 낮아서
    서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응집도 높은 코드가 나온다.

#### 5-4 메일 서비스 추상화
###### 코드 추가
    1. User email 필드 추가
    2. JavaMail 에 대한 추상화 인터페이스 MailSender 사용
    3. 스프링 DI 적
    4. 테스트용 DummyMailSender 추가
    5. 목 오브젝트 MockMailSender 추가
###### gradle 추가
    Session class 사용
    compile group: 'javax.mail', name: 'mail', version: '1.4.7'
    compile group: 'javax.activation', name: 'activation', version: '1.1.1'
    MailSender, JavaMailSenderImple 사용
    compile group: 'org.springframework', name: 'spring-context-support', version: '5.2.5.RELEASE'
###### 정리
    자바에서 메이ㄹ을 발송할 때는 표준 기술인 JavaMail 을 사용
    그러나 JavaMail 은 확장이나 지원이 불가능하도록 만들어진 악명 높은 표준 API 중 하나
    그래서 스프링에서는 JavaMail 을 사용해 만든 추상화 기능을 가진 인터페이스 제공
    MailSender 라는 이 인터페이스는 SimpleMailMessage 라는 인터페이스를 매개 변수로 받아 발송하는 기능만 가지고 있음
    
    일반적으로 서비스 추사화란 유사하나 사용 방법이 다른 로우레벨의 다양한 기술에 대해 
    추상 인터페이스와 "일관성 있는 접근 방법"을 제공해주는 것을 말함
    
    테스트 대역
    테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게,
    자주 테스트를 실행할 수 있도록 사용하는 오브젝트
    
    테스트 스텁
    테스트 대상 오브젝트의 의존객체로서 존재하면서 테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕는 것
    
    목 오브젝트
    스텁처럼 테스트 오브젝트가 정상적으로 실행되도록 도와주면서, 테스트 오브젝트와 자신의 사이에서
    일어나는 커뮤니케이션 내용을 저장해뒀다가 테스트 결과를 검증하는 데 활용

#### 6-1 트랜잭션 코드의 분리
###### 코드 추가
    1. 비즈니스 로직을 메서드 단위로 분리
    2. UserService 를 UserServiceImpl 로 이름 변경 트랜잭션 기능 제거, UserService interface 추가
    3. 트랜잭션 기능을 담은 UserServiceTx 추가
###### 정리
    보통 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시에 DI 를 이용해
    적용하는 방법을 쓰는 이유는, 일반적으로 구현 클래스를 바꿔가면서 사용하기 위해서다.
    
    트랜잭션을 로직을 분리하는 방법
    트랜잭션을 적용한 로직, 또는 적용하지 않은 로직을 사용하기 위해
    트랜잭션이 적용된 클래스, 트랜잭션이 적용되지 않은 클래스로 나눈다.
    공통 메서드를 추상화 한 인터페이스를 정의하고
    인터페이스를 구현한다
    트랜잭션이 적용된 클래스에서는 메서드를 실행할 때,
    해당 트랜잭션 경계 설정을 수행한 후 DI 받은 인터페이스 구현체의 메서드를 실행한다.
    트랜잭션 적용 오브젝트에서 트랜잭션 경계설정 후 -> 해당 로직 ( DI 받은 인터페이스 구현체 ) -> 트랜잭션 경계설정 해제
    순으로 로직이 실행된다.

#### 6-2 고립된 단위 테스트
###### 코드 추가
    1. 테스트를 위한 MockUserDao 추가
    2. Mokito 프레임워크 사용 하여 목 오브젝트 대체테스트 작성
###### gradle 추가
    Mockito 프레임워크 사용
    testCompile group: 'org.mockito', name: 'mockito-core', version: '3.3.3'
###### 정리
    가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것
    작은 단위의 테스트가 좋은 이유는 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문이다.
    테스트 단위가 작아야 테스트의 의도나 내용이 분명해지고, 만들기도 쉬워진다.
    테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.
    방법은 테스트를 위한 대역을 사용하는 것
    
    의존 오브젝트나 외부 서비스에 의존하지 않는 고립된 테스트 방식으로 만든 오브젝트는 아무리 그 기능이 수행돼도
    그 결과가 DB 등을 통해서 남지 않으니, 작업 결과를 검증하기 힘들다.
    이럴 땐 테스트 대상이 어떤 요청을 했는지를 확인하는 작업이 필요하다.
    주고받은 정보를 저장해뒀다가 테스트의 검증에 사용할 수 있게 하는 목 오브젝트를 만들 필요가 있음.
    
    단위 테스트
    단위 테스트의 단위는 정하기 나름이다. 사용자 관리 기능 전체를 하나의 단위로 볼 수도 있고
    하나의 클래스나 하나의 메서드를 단위로 볼 수도 있다. 중요한 것은 하나의 단위에 초점을 맞춘다는 것이다.
    
    하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고
    필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하도록 테스트를 만든다.
    
    코드를 만들고 나서 오랜 시간이 지난 뒤에 작성하는 테스트는 테스트 대상 코드에 대한 이해가 떨어지기 때문에
    불완전해지기 쉽고 작성하기도 번거롭다.
    코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관이다.
    테스트하기 편하게 만들어진 코드는 깔끔하고 좋은 코드가 될 가능성이 높다.
    
    목 오브젝트 사용
    의존성 없는 테스트를 작성하기 위해 목 오브젝트를 사용하다보면 테스트를 위해 만들어야 할 오브젝트가
    많아질 수 있다. 그래서 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 만들어졌다.
    
    Mockito
    많은 인기를 끌고 있는 목 오브젝트 프레임워크
    간단한 메소드 호출만으로 다이나믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.
    사용법
        mock() : 목오브젝트 생성
        when() : ~할 때
        thenReturn(변수) : 변수로 리턴해라
        times() : 호출 횟수
        verify() : 확인하라
    단계
        1. 인터페이스를 이용해 목 오브젝트를 만든다.
        2. 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메서드가 호출되면 예외를 강제로 던지가 만들 수 있다.
        3. 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
        4. 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메서드가 호출 됐는지, 어떤 값을 가지고
           몇 번 호출됐는지를 검증한다.
    
#### 6-3 다이나믹 프록시와 팩토리 빈-1
###### 코드 추가
    1. ReflectionTest 추가
    2. Proxy Test 를 위한 Hello 인터페이스 와 타겟 HelloTarget, 프록시 HelloUppercase 추가
    3. InvocationHandler 구현 클래스 UppercaseHandler 추가
    4. UserServiceTx 를 다이나믹 프록시 방식으로 변경하기 위한 TransactionHandler 추가
    5. FactoryBean 인터페이스 구현을 위한 클래스 Message 추가
###### 정리
    자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을
    대리자, 대리인과 같은 역할을 한다고 해서 프록시라고 부른다.
    프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃 또는 실체라고 부른다.
    
    프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것
    프록시는 사용 목적에 따라 두 가지로 구분
    1. 클라이언트가 타깃에 접근하는 방법을 제어 - 프록시 패턴
    2. 타깃에 부가적인 기능을 부여 - 데코레이터 패턴
    
    데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
    코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않다.
    프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에
    자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.
    
    프록시 패턴은 타깃에 대한 접근 방법을 제어하려는 목적으로 사용한다.
    클라이언트가 타깃에 접근하는 방식을 변경
    타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우에는 
    꼭 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다.
    클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트를 만드는 대신
    프록시를 넘겨주는 것이다.
    그리고 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고
    요청을 위임하는 방식
    프록시 패턴의 타깃은 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용
    구조적으로 보자면 프록시와 데코레이터는 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃
    클래스 정보를 알고 있는 경우가 많다.
    
    다이나믹 프록시
    프록시를 만들기 위해서는 매번 새로운 클래스를 정의하고 인터페이스를 구현해야 하기 때문에
    상당히 번거로운 일이다.
    자바에서는 java.lang.reflect 패키지로 프록시를 손쉽게 만들 수 있도록 지원한다.
    
    리플렉션
    다이나믹프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
    리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든것이다.
    클래스 오브젝트를 이용하면 클래스 코드에 대한 메타정보를 가져오거나 오브젝트를 조작할 수 있다.
    클래스의 이름, 상속, 구현, 필드값, 타입, 메서드 정의, 파라미터, 리턴타입 등을 알아낼 수 있다.
    원하는 파라미터 값을 이용해 메서드를 호출하고 오브젝트의 필드값을 읽고 수정할 수 있다.
    
    다이나믹 프록시는 프록시 팩토리에 의해 런타임 시 다이나믹하게 만들어지는 오브젝트다.
    다이나믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 만들어진다.
    클라이언트는 다이나믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다.
    프록시를 만들 때 인터페이스를 모두 구현하지 않아도 된다.
    인터페이스 저보만 제공해주면 해당 구현 클래스 오브젝트를 자동으로 만들어 준다.
    
    InvocationHandler 인터페이스를 사용하여 구현
    구현한 클래스와 Proxy.newProxyInstance 를 이용하여 다이나믹 프록시 생성
    
    그러나 문제는 DI 의 대상이 되는 다이나믹 프록시 오브젝트는 일반적인 스프링의 빈으로는 등록할 수가 없다.
    스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해 해당 클래스의 오브젝트를 만든다.
    스프링은 내부적으로 리플렉션 API 를 이용해 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성
    다이나믹 프롣시 오브젝트의 클래스가 어떤 것인지도 알 수 없고, 
    클래스 자체도 내부적으로 다이나믹하게 새로 정의해서 사용
    
    팩토리 빈
    스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈
    FactoryBean 인터페이스를 구현
    FactoryBean 의 getObject 메서드가 생성해주는 오브젝트가 빈으로 등록된다.
    
#### 6-3 다이나믹 프록시와 팩토리 빈-2
###### 코드 추가
    1. Transaction Handler 를 이용하는 다이나믹 프록시 TxProxyFactoryBean 추가
###### 문제점
    프록시 팩토리 빈의 한계
    프록시를 통해 타깃에 부가기능을 제공하는 것은 메서드 단위의 일
    따라서 여러 개의 클래스에 부가 기능을 제공하는 것은 불가능하다.
    또한 하나의 타깃에 어려 개의 부가기능을 적용하는 것도 문제다.
    TransactionHandler 오브젝트가 프록시 팩티로 빈 개수만큼 만들어진다.
###### 정리
    프로퍼티의 타입이 Class 인 경우는 value 로 설정한 이름을 가진 Class 오브젝트로
    자동 변환해 줌
    
    데코레이터 패턴의 문제점은 프록시를 적용할 대상이 구현하고 있는 인터페이스를 구현하는
    프록시 클래스를 일일이 만들어줘야 하는점, 부가적인 기능이 여러 메서드에 반복적으로
    나타나게 돼서 코드 중복이 발생한다는 점이었다.
    
    다이나믹 프록시는 리플렉션을 이용하여 이 문제점들을 제거할 수 있다.
    
#### 6-4 스프링의 프록시 팩토리 빈-1
###### 정리
    스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공해준다.
    스프링의 ProxyFactoryBean 은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다.
    ProxyFactoryBean 은 프록시를 생성하는 작업만 담당하고, 부가기능은 MethodInterceptor 를 구현해서 만든다.
    MethodInterceptor 는 InvocationHandler 와 다르게 타깃 오브젝트에 대한 정보까지 함께 제공받는다.
    
    ProxyFactoryBean 에는 여러 개의 MethodInterceptor 를 추가할 수 있다.
    ProxyFactoryBean 하나로 여러 개의 부가기능을 제공해주는 프록시를 만들 수 있다는 뜻이다.
    
    MethodInterceptor 는 Advice 인터페이스를 상속하고 있는 서브 인터페이스 이다.
    타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트를 스프링에서는 어드바이스 라고 부른다.
    MethodInterceptor 는 InvocationHandler 와 다르게 구현할 인터페이스를 알려주지 않는다.
    인터페이스를 굳이 알려주지 않아도 ProxyFactoryBean 에 있는 "인터페이스 자동검출" 기능을 이용해
    타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아낸다.
    구현하는 인터페이스 중에서 일부만 프록시에 적용하길 원한다면 인터페이스 정보를 제공해도 된다.
    
    MehtodInterceptor 는 여러 프록시가 공유해서 사용할 수 있다.
    때문에 타깃 정보를 갖고 있지 않도록 만들었다.
    그래서 트랜잭션 적용 메서드 패턴은 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 MethodInterceptor 에
    특정 프록시만 적용되는 패턴을 넣으면 문제가 된다.
    
    그래서 스프링은 메서드 선정 알고리즘을 담은 클래스를 제공한다.
    포인트컷은 메서드 선정 알고리즘을 담은 오브젝트이다.
    프록시는 클라이언트로부터 요청을 받으면 먼저 포인트컷에게 부가기능을 부여할 메서드인지를 확인해달라고 요청한다.
    포인트컷이 필요 없을 때는 ProxyFactoryBean 의 addAdvice() 메서드를 호출해서 어드바이스만 등록하면 된다.
    어드바이스와 포인트컷을 묶은 오브젝트를 인터페이스 이름을 따서 어드바이저 라고 한다.
    
#### 6-4 스프링의 프록시 팩토리 빈-2
###### 코드 추가
    1. MethodInterceptor 구현체 TransactionAdvice 추가
    2. 구현한 TransactionAdvice 와 NameMatchMethodPointcut 을 이용하여 Advisor(DefaultPointcutAdvisor) DI 
###### 정리
    xml 스프링 환경설정 파일에서
    어드바이저는 interceptorNames 라는 프로퍼티를 통해 넣는다.
    어드바이스와 어드바이저를 혼합해서 설정할 수 있도록 property 태그 대신 list 와 value 태그를 통해
    여러 개의 값을 넣을 수 있또록 하고 있다.
    value 태그에는 어드바이스 또는 어드바이저로 설정한 빈의 아이디를 넣으면 된다.

#### 6-5 스프링 AOP-1
###### 문제점
    설정 정보에서 타깃 오브젝트가 추가 될때마다 다른 타깃 오브젝트에 같은 빈 클래스종류, 어드바이스, 포인트 컷을 등록해줘야함
###### 정리
    JDK 의 다이나믹 프록시는 특정 인터페이스를 구현한 오브젝트에 대해서 프록시 역할을 해주는 클래스를 "런타임" 시에 만들어준다.
    그 덕분에 개발자가 일일이 인터페이스 메서드를 구현하는 프록시 클래스를 만들어서 위임과 부가기능의 코드를
    중복해서 넣어주지 않아도 되었다.
    
    스프링이 DI 를 이용해 만들어지는 애플리케이션 코드가 OCP 에 충실할 수 있도록 한다면, 스프링 스스로도 그 가치를 따르는 게 마땅하다.
    스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분 외에는 대부분 확장할 수 있도록 확장 포인트를 제공한다.
    
    그 확장 포인트 중 BeanPostProcessor 인터페이스를 구현해서 만드는 빈 후처리기가 있다.
    빈 후처리기는 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준다.
    스프링이 제공하는 빈 후처리기 중 하나인 DefaultAdvisorAutoProxyCreator 는 어드바이저를 이용한 자동 프록시 생성기다.
    빈 후처리기를 스프링에 적용하는 방법은
    빈 후처리기 자체를 빈으로 등록하고, 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청,
    후처리 작업 후 생성된 프록시로 포장된 오브젝트를 컨테이너에 돌려준다.
    빈 후처리기는 빈 오브젝트의 프로퍼티를 강제로 수정할 수도 있고 별도의 초기화 작업을 수행할 수도 있다.
    심지어는 만들어진 빈 오브젝트 자체를 바꿔치기할 수 도 있다.
    
#### 6-5 스프링 AOP-2
###### 코드 추가
    1. NameMatchMethodPointcut 을 상속하며 클래스 이름을 비교하는 ClassFilter 메서드를 포함하는 NameMatchClassMethodPointcut 추가
    2. 포인트컷 표현식 테스트용 TargetInterface, Target, Bean 추가
###### gradle 추가
    AspectJExpressionPointcut 으로 읽어 오는데? reflectionWorldException 발생
    compile group: 'org.aspectj', name: 'aspectjweaver', version: '1.9.4'
###### 문제점
    테스트 에러
    자동 프록시 생성기가 알아서 프록시를 만들어 줬기 때문에 ProxyFactoryBean 같은 팩토리 빈이 존재하지 않는다.
    자동 프록시 생성기라는 스프링 컨테이너에 종속적인 기법을 사용했기 때문에 예외상황을 위한 테스트 대상도 빈으로 등록해 줄 필요가 있다.
###### 정리
    프록시 자동생성기에 빈 후처리기 매커니즘을 적용하고 나면 최소한 두가지는 확인해야한다.
    첫째는 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용됐는지
    둘째는 아무 빈에나 트랜잭션 부가기능이 적용된 것은 아닌지 확인해야한다.
    
    포인트컷 표현식
    메서드의 이름과 이름과 클래스의 이름 패턴을 각각 클래스 필터와 메서드 매처 오브젝트로 비교해서 선정하는 방식에서
    더 족잡하고 세밀한 기준을 이용해 클래스나 메서드를 선정하기 위해 스프링에서 아주 간단하고 효과적인 방법으로 
    포인트컷의 클래스와 메서드를 선정하는 알고리즘을 작성할 수 있는 방법을 제공한다.
    정규식이나 JSP 의 EL 과 비슷한 표현식 언어를 사용해서 포인트컷을 작성하는 방법이다.
    
    AspectJExpressionPointcut 클래스를 사용하여 클래스와 메서드의 선정 알고리즘을 포인트컷 표현식을 이용해
    한 번에 지정할 수 있게 해준다.
    문법 : execution([ 접근제한자 패턴 ] 타입패턴 [ 타입패턴. ]이름패턴 ( 타입패턴 | "..", ... )
    e.g) public int dao.Target.minus(int,int) throws java.lang.RuntimeException
         public : 접근제한자, 생략 O
         int : 리턴 타입, 생략 X
         dao.Target : 클래스 "타입" 패턴, 생략 X
         minus : 메서드 이름 패턴, 생략 X
         (int,int) : 메서드 파라미터 타입 패턴, 생략 X
         throws java.lang.RuntimeException : 예외 이름 타입 패턴, 생략 O
          
    포인트컷 표현식을 사용하면 로직이 짧은 문자열에 담기기 때문에 클래스나 코드를 추가할 필요가 없어서 코드와 설정이 모두 단순해진다.
    반면 문자열로 된 표현식이므로 런타임 시점까지 문법의 검증이나 기능 확인이 되자 않는다는 단점도 있다.
    그렇기 때문에 다양한 테스트를 미리 만들어서 검증한 표현식을 사용해야 한다.
    
    포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름이 아닌 타입 패턴이다.
    적용할 이름의 슈퍼클래스와 구현 인터페이스 까지 모두 포함한다.
    
#### 6-5 스프링 AOP-3
###### 정리
    AOP 를 향하여
    
    트랜잭션 추상화란 인터페이스와 DI 를 통해 무엇을 하는지 남기고, 그것을 어떻게 하는지를 분리한 것
    
    투명한 부가기능 부여를 가능하게 하는 "데코레이터 패턴"의 적용 덕에 비즈니스 로직을 담당하는 클래스도 
    자신을 사용하는 클라이언트와 DI 관계를 맺을 이유를 찾게 됐다. 클라이언트가 인터페이스와 DI 를 통해 
    접근하도록 설계하고, 데코레이터 패턴을 적용해서, 비즈니스 로직을 담은 클래스의 코드에는 
    전혀 영향을 주지 않으면서 트랜잭션이라는 부가기능을 자유롭게 부여할 수 있는 구조를 만들었다.며
    
    프록시 클래스 없이도 프록시 오브젝트를 런타임 시에 만들어주는 JDK 다이나믹 프록시 기술을 적용
    하지만 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로는 중복이 일어남
    스프링의 프록시 팩토리 덕분에 부가기능을 담은 어드바이스와 부가기능 선정 알고리즘을 담은
    포인트컷은 프록시에서 분리될 수 있었고 여러 프록시에서 공유해서 사용
    
    스프링 컨테이너의 빈 생성 후처리 기법을 활용, 포인트컷 표현식 사용
    
    관심사가 같은 코드를 분리해 한데 모으는 것은 소프트웨어 개발의 가장 기본이 되는 원칙이다.
    코드를 분리, 한데 모으고, 인터페이스 도입, DI 를 통해 런타임 시에 의존관계를 만들어줌
    
    애스팩트란 그 자체로 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 요소이고,
    핵심기능에 부가되어 의미를 갖는 특별한 모듈을 가리킨다.
    애스팩트로 분리한 덕에 핵심기능은 순수하게 그 기능을 담은 코드로만 존재하고 독립적으로 살펴 볼 수 있도록 구분된 면에 존재
    애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스팩트라는
    독특한 모듈로 만들어서 설계하고 개발하는 방법을 애스팩트 지향 프로그래밍이라고 한다.
    애플리케이션을 관점에서 바라보고 그 부분에 집중해서 설계하고 개발할 수 있게 된다는 뜻
    
    스프링 AOP 는 프록시 방식의 AOP 이다.
    프록시 방식이 아닌 AspectJ 는 타깃 오브젝트를 뜯어고쳐서 부가 기능을 직접 넣어주는 직접적인 방법을 사용
    컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM 에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용
    장점은 DI 컨테이너의 도움을 받지 않아도 AOP 적용, 프록시 방식보다 훨씬 강력하고 유연한 AOP 적용 가능
    
    AOP 용어
    타깃 : 부가기능을 부여할 대상
    어드바이스 : 타깃에게 제공할 부가기능을 담은 모듈
    조인포인트 : 어드바이스 적용될 수 있는 위치
    포인트컷 : 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈
    프록시 : 클라이언트와 타깃사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트
    어드바이저 : 포인트컷과 어드바이스르 하나씩 갖고 있는 오브젝트
    
    스프링 AOP
    자동 프록시 생성기 : DefaultAdvisorAutoProxyCreator 클래스는 프록시를 자동으로 생성
    어드바이스 : TransactionAdvice 클래스는 직접 구현하여 사용
    포인트컷 : AspectJExpressionPointcut 사용 expression 에 포인트컷 표현식 넣어줌
    어드바이저 : DefaultPointcutAdvisor 클래스 사용 어드바이스와 포인트컷 참조하여 등록

#### 6-6 트랜잭션 속성
###### 정리
    TransactionDefinition 인터페이스는 네가지 트랜잭션 속성을 정의하고 있다.
    트랜잭션 전파, 격리수준, 제한시간, 읽기전용
    
    트랜잭션 전파란 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식
    트랜잭션 전파에는 두가지 방식이 있는데 하나는 이미 시작한 트랜잭션에 참여하여 예외가 발생했을땐 모든 DB 의 작업을 취소한다.
    또 하나는 독립적인 트랜잭션으로 만들어져 독자적으로 커밋 또는 롤백되고 전에 진행하던 트랜잭션에 영향을 받지 않는다.
    
    트랜잭션 전파 속성
    PROPAGATION_REQUIRED : 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여
    PROPAGATION_REQUIRES_NEW : 항상 새로운 트랜잭션을 시작, 이미 시작된 트랜잭션이 있어도 독자적으로 동작
    PROPAGATION_NOT_SUPPORTED : 트랜잭션 없이 동작, 이미 시작된 트랜잭션이 있어도 무시
    
    격리수준
    격리수준을 조정해서 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 하는 제어가 필요
    격리수준은 기본적으로 DB 에 설정되어 있지만 DataSource 나 JDBC 드라이버 등에서도 설정할 수 있다.
    
    제한시간
    트랜잭션을 수행하는 제한시간을 설정할 수 있다.
    
    읽기전용
    읽기전용은 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있다.
    
    스프링이 제공하는 TransactionInterceptor 에는 두가지 종류의 예외처리 방식이 있다.
    런타임 예외가 발생하면 트랜잭션 롤백,
    체크 예외가 발생하면 예외상황으로 해석하지 않고 트랜잭션 커밋,
    그리고 이런 예외처리 기본원칙을 따르지 않을때 ( 예외상황이 뜻하지 않게 발생했을 때 ) 를 
    대비해 rollbackOn() 이라는 속성을 둬서 기본 원칙과 다른 예외 처리가 가능하게 해준다.
    
    TransactionInterceptor 의 Properties 타입의 transactionAttributes 프로퍼티는
    메서드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션이다.
    트랜잭션 속성은 문자열로 정의할 수 있다.
    
    PROPAGATION_NAME, ISOLATION_NAME, readOnly, timeout_NNNN, -Exception1, +Exception2
    
    PROPAGATION_NAME : 트랜잭션 전파 방식, 필수 항목, PROPAGATION_ 으로 시작
    ISOLATION_NAME : 격리수준, 생략 가능, ISOLATION_ 으로 시작
    readOnly : 읽기전용, 생략 가능
    timeout_NNNN : 제한시간, NNNN 부분에 시간을 붙임, 생략 가능
    -Exception : 체크 예외 중 롤백 대상으로 추가할 예외, 한 개 이상 등록 가능
    +Exception : 런타임 예외 중 롤백시키지 않을 예외, 한 개 이상 등록 가능
    
    e.g ) 
    <prop key="get*">PROPAGATION_REQUIRED,readOnly,timeout_30</prop> 
    <prop key="upgrade*">PROPAGATION_REQUIRES_NEW,ISOLATION_SERIALIZABLE</prop>
    
    트랜잭션 속성 중 readOnly 나 timeout 등은 트랜잭션이 처음 시작될 때가 아니라면 적용되지 않는다.
    
    메서드 이름이 하나 이상의 패턴과 일치하는 경우에는 메서드 이름 패턴 중에서 가장 정확히 일치하는 것이 적용
    
    포인트컷 표현식과 트랜잭션 속성의 정의할 때 따르면 좋은 몇 가지 전략
    1. 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용
       가능하면 클래스보다는 인터페이스 타입을 기준으로 타입 패턴을 적용하는 것이 좋다.
       bean() 표현식은 빈 이름을 기준으로 선정하기 때문에 클래스나 인터페이스 이름에 
       일정한 규칙을 만들기가 어려운 경우에 용이
    2. 공통된 메서드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.
    3. 프록시 방식 AOP 는 같은 타깃 오브젝트 내의 메서드를 호출할 때는 적용되지 않는다.
       프록시 방식의 AOP 에서는 프록시를 통한 부가기능의 적용은 클라이언트로부터 호출이 일어날 때 가능
       타깃 안에서의 호출에는 프록시가 적용되지 않는다.
       이 문제를 해결할 수 있는 방법은 스프링 API 를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤
       프록시를 이용하거나 AspectJ 와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 사용

#### 6-7 애노테이션 트랜잭션 속성과 포인트
###### 정리
    @Transactional 어노테이션을 트랜잭션 속성정보로 사용하도록 지정하면
    스프링은 @Transactional 어노테이션이 부여된 모든 오브젝트를 자동으로 타깃 오브젝트로 인식한다.
    @Transactional 이 타입 레벨이든 메서드 레벨이든 상관없이 
    부여된 빈 오브젝트를 모두 찾아서 포인트컷의 선정 결과로 돌려준다.
    @Transactional 은 트랜잭션 속성을 정의하고, 동시에 포인트컷을 자동등록해준다.
    
    @Transactional 은 메서드마다 다르게 설정할 수도 있으므로 매우 유연한 트랜잭션 속성 설정이 가능해진다.
    메서드마다 부여하여 유연한 속성 제어가 가능하지만 코드는 지저분해지며, 동일한 속성 정보를 가진 어노테이션을
    메서드마다 일일이 부여해줘야 한다.
    
    그래서 스프링은 대체 정책을 이용한다.
    메서드의 속성을 확인할 때 타깃 메서드, 타깃 클래스, 선언 메서드, 선언 타입 순서에 따라서 확인하고,
    가장 먼저 발견되는 속성 정보를 사용한게 한다.
    e.g ) 구현 class method -> 구현 class -> interface method -> interface
    
    @Transactional 적용 대상은 클라이언트가 사용하는 인터페이스가 정의한 메서드이므로 
    인터페이스에 정의하는 것이 바람직 하지만,
    인터페이스를 사용하는 프록시 방식의 AOP 가 아닌 방식으로 트랜잭션을 적용하면 
    인터페이스에 정의한 @Transactional 이 무시되기 때문에
    안전하게 타깃 클래스에 @Transactional 을 두는 방법을 권장한다.
    
    @Transactional 은 직관적이고 간단하며 단순하게 트랜잭션이 필요한 타입 또는 메서드에 직접 어노테이션을
    부여하는 것이 훨씬 편리하고 이해하기도 좋다.
    하지만 트랜잭션 적용 대상을 손쉽게 파악할 수 없고, 사용 정책을 만들어주디 않으면 무분별하게 사용되거나
    빼먹을 위험도 있다.

#### 6-7 트랜잭션 지원 테스트
###### 정리
    AOP 를 이용해 코드 외부에서 트랜잭션 기능을 부여해주고 속성을 지정 할 수 있게 하는 방법을 선언적 트랜잭션,
    반대로 TransactionTemplate 이나 개별 데이터 기술의 트랜잭션 API 를 사용해 직접 코드안에서 
    사용하는 방법은 프로그램에 의한 트랜잭션 이라고 한다.
    
    트랜잭션을 통합하는 방법은 메소드들을 호출하기 전에 트랜잭션을 미리 시작하면 된다.
    트랜잭션의 전파는 트랜잭션 매니저를 통해 트랜잭션 동기화 방식이 적용된다.
    
    롤백 테스트는 DB 작업이 포함된 테스트가 수행돼도 DB 에 영향을 주지 않기 때문에 장점이 많다.
    테스트용 데이터를 DB 에 잘 준비해놓더라도 앞에서 실행된 테스트에서 DB 의 데이터를 바꿔버리면
    이후에 실행되는 테스트에 영향을 미칠 수 있다.
    
    @Transactional 어노테이션을 테스트 메서드에도 추가할 수 있다.
    @Rollback 어노테이션이 달린 테스트용 트랜잭션은 테스트가 끝나면 자동으로 롤백된다.
    
    의존, 협력 오브젝트를 사용하지 않고 고립된 상태에서 테스트를 진행하는 단위 테스트와,
    DB 같은 외부의 리소스나 여러 계층의 클래스가 참여하는 통합 테스트는 아예 클래스를 구분해서 따로 만드는게 좋다.
    
    테스트는 어떤 경우에도 서로 의존하면 안된다.
    코드가 바뀌지 않는 한 어떤 순서로 진행되더라도 테스트는 일정한 결과를 내야 한다.
    
    
## 스프링이 가장 가치를 두고 적극적으로 활용하려고 하는 것은
## 결국 자바 언어가 기반을 두고 있는 객체지향 기술이다.

#### 7-1 SQL 과 DAO 의 분리
###### 코드 추가
    1. SQL 제공 서비스를 위한 SqlService 인터페이스 추가
    2. 주어진 키를 가지고 SQL 을 가져오다 실패했을 경우 던질 예외 SqlRetrievalFailureException 추가

#### 7-2 인터페이스의 분리와 자기참조 빈
###### 코드 추가
    1. SQL 을 XML 파일로 옮기기 위한 xsd 파일 추가
    2. 프로젝트 루트 경로에서 xjc -p "추가할클래스패키지" "파일이름.xsd" -d "저장할위치"
        - "저장할위치" 안의 "추가할클래스패키지" 안에 "파일이름.xsd" 를 컴파일 한 클래스 들이 생성됨
    3. xml 파일에서 SQL 을 읽어와 적용할 SqlService 구현체인 XmlSqlService 추가
    4. XmlSqlService 의 관심사를 나눈 SqlReader ( 읽어오고 ) SqlRegistry ( 적용 할 ) 인터페이스 추가
    5. SqlReader 를 구현한 JaxbXmlSqlReader, SqlRegistry 를 구현한 HashMapSqlRegistry 추가
    6. 아무 추가 내용 없을 때 사용할 DefaultSqlService 추가
###### 정리
    JAXB 은 XML 문서정보를 거의 동일한 구조의 오브젝트로 직접 매핑
    
    XML 문서를 읽어서 자바의 오브젝트로 변환하는 것을 언마샬링
    바인딩 오브젝트를 XML 문서로 변환하는 것을 마샬링 이라 함
    
    @PostConstruct 를 초기화 작업을 수행할 메서드에 부여해주면
    스프링은 빈의 오브젝트를 생성하고 DI 작업을 마친 뒤에 @PostConstruct 가 붙은
    메서드를 자동으로 실행해준다. 생성자와는 달리 프로퍼티까지 모두 준비된 후에 실행된다는
    면에서 @PostConstruct 초기화 메서드는 매우 유용하다.
    <context:annotation-config /> 를 등록해야함 빈 후처리기 사용을 위해
    
    자바의 오브젝트는 데이터를 가질 수 있다. 자신이 가진 데이터를 이용해 어떻게 작업해야 할지도 가장 잘 알고 있다.
    그렇다면 오브젝트 스스로 자신의 데이터로 충실히 작업하게 만들면 되지, 
    쓸데없이 오브젝트 내부의 데이터를 외부로 노출시킬 필요는 없다.
    
    자기 자신을 참조하는 빈은 흔히 쓰이는 방법은 아니다. 
    책임이 다르다면 클래스를 구분하고 각기 다른 오브젝트로 만들어지는 것이 자연스럽다.
    다만 자기참조 빈을 만들어보는 것은, 책임과 관심사가 복잡하게 얽혀 있어서 
    확장이 힘들고 변경에 취약한 구조의 클래스를 유연한 구조로 만들려고 할 때 시도해 볼수 있는 방법이다. 
    
#### 7-3 서비스 추상화 적용
###### 코드 추가
    1. XML 파일을 Java 오브젝트로 변경해줄 여러 OXM 기술을 사용하기 위한 추상화 클래스들 추가
###### gradle 추가
    // oxm 사용
    compile group: 'org.springframework', name: 'spring-oxm', version: '3.0.0.RELEASE'
    // jaxb xml bind 에러
    compile group: 'org.glassfish.jaxb', name: 'jaxb-runtime', version: '2.3.2'
    // postconstruct 에러
    compile group: 'javax.annotation', name: 'javax.annotation-api', version: '1.3.2'
    // castor 사용
    compile group: 'org.codehaus.castor', name: 'com.springsource.org.castor', version: '1.2.0'
###### 정리
    XML 과 자바 오브젝트를 매핑해서 상호 변환해주는 기술을 OXM 이라고 한다.
    
    두 개의 클래스를 강하게 결합하고 더 이상의 확장이나 변경을 제한해두는 이유는 서비스 구조로 최적화 하기 위해서다.
    편리한 확장과 유연한 변경을 위해서 클래스를 분리하고 빈을 따로 등록해 DI 할 수 있도록 기본 구조를 가져간 것은 좋지만,
    자꾸 늘어나는 빈의 개수와 반복되는 비슷한 DI 구조가 불편하게 느껴질 수도 있다.
    
    스프링의 거의 모든 API 는 외부의 리소스 정보가 필요할 때는 항상 이 Resource 추상화를 이용한다.
    스프링에는 URL 클래스와 유사하게 접두어를 이용해 ResourceLoader 를 통하여 Resource 오브젝트를 선언하는 방법이 있다.
    접두어가 없는 경우에는 리소스 로더의 구현 방식에 따라 리소스를 가져오는 방식이 달라진다.
    접두어를 붙여주면 리소스 로더의 종류와 상관없이 접두어가 의미하는 위치와 방법을 이용해 리소스를 읽어온다.
    
    Resource 를 사용할 때는 Resource 오브젝트가 실제 리소스는 아니라는 점을 주의해야 한다.
    Resource 는 단지 리소스에 접근할 수 있는 추상화된 핸들러일 뿐이다.
    따라서 Resource 타입의 오브젝트가 만들어졌다고 해도 실제로 리소스가 존재하지 않을 수 있다.

#### 7-4 인터페이스 상속을 통한 안전한 기능확장
###### 코드 추가
    1. 기존 SqlRegistry 의 기능을 확장( updatable 업데이트 기능 )한 UpdatableSqlRegistry 인터페이스 추가
###### 정리
    DI 를 적용하려면 최소한 두개 이상의, 의존 관계를 가지고 소ㅓ로 협력해서 일하는 오브젝트가 필요하다.
    적절한 책임에 따라 오브젝트를 분리해주고 항상 오브젝트는 자유롭게 확장될 수 있다는 것을 염두에 둬야 한다.
    DI 는 런타임 시에 의존 오브젝트를 다이나믹하게 연결해줘서 유연한 확장을 꾀하는게 목적이다.
    확장은 미래에 일어나는 일이다. DI 는 확장을 위해 필요한 것이므로 항상 미래에 일어날 변화를 예상하고 고민하여 설계해야 한다.
    
    DI 를 DI 답게 만들려면 두 개의 오브젝트가 인터페이스를 통해 느슨하게 연결돼야 한다.
    인터페이스를 사용하는 첫 번째 이유는 다형성을 얻기 위해서다.
    또 다른 이유는 인터페이스 분리 원칙을 통해 클라이언트와 의존 오브젝트 사이의 관계를 명확히 하기 위해서다.
    오브젝트가 그 자체로 충분히 응집도가 높은 작은 단위로 설계됐더라도, 목적과 관심이 각기 다른 클라이언트가 있다면
    인터페이스를 통해 이를 적절하게 분리해줄 필요가 있다. 이를 인터페이스 분리 원칙이라고 부른다.
    
    인터페이스 분리 원칙이 주는 장점은 모든 클라이언트가 자신의 관심에 따른 접근 방식을 불필요한 간섭 없이 유지할 수 있다는 점이다.
    그래서 기존 클라이언트에 영향을 주지 않은 채로 오브젝트의 기능을 확장하거나 수정할 수 있다. 
    
    인터페이스를 통한 DI 를 사용하면 동일한 오브젝트에 의존하고 있어도 각자의 관심과 필요에 따라서 다른 인터페이스를 통해 접근이 가능하다.
    
    잘 적용된 DI 는 결국 잘 설계된 오브젝트 의존관계에 달려 있다.
    인터페이스를 적절하게 분리하고 확장하는 방법을 통해 오브젝트 사이의 의존관계를 명확하게 해주고,
    기존 의존관계에 영향을 주지 않으면서 유연한 확장성으 얻는 방법이 무엇인지 항상 고민해야 한다.
    
#### 7-5 DI 를 이용해 다양한 구현 방법 적용하기
###### 코드 추가
    1. 멀티 스레드 환경 대비 기존 sql 을 담고 있던 HashMap 을 ConcurrentHashMap 으로 변환
    2. 스프링의 내장형 DB 를 사용하는 EmbeddedDbSqlRegistry 추가
    3. EmbeddedDbSqlRegistry 에 트랜잭션 적용
###### gradle 추가
    // 내장 DB 사용
    testCompile group: 'hsqldb', name: 'hsqldb', version: '1.8.0.10'
###### 정리
    굳이 모든 테스트를 작성한 후에 코드를 만들 필요는 없다.
    만들어야할 기능에 대해 테스트 메서드를 하나씩 추가하면서 이 테스트를 성공 시킬 수 있게 만들어도 좋고,
    테스트를 먼저 만드는 게 불편하다면 인단 코드를 먼저 만들고 그에 대한 테스트를 바로 추가해서 확인해 보는 방법도 나쁘지 않다.
    중요한 건 코드를 작성한 다음 테스트를 만들어 검증하는 그 사이의 간격을 가능한 짧게 하고,
    예외상황을 포함한 기능을 세세하게 검증하도록 테스트를 만드는 것이다.

#### 7-6 스프링 3.1 의 DI
###### 코드 추가
    1. 기존의 XML 파일의 <bean> 으로 정의 되어있는 객체를 @Bean 어노테이션으로 대체
    2. 역할에 따른 컨텍스트 분리 @Import 어노테이션을 통한 컨텍스트 주입
###### 정리
    자바 언어의 변화가 생기며 원래 리플렉션 API 는 자바 코드나 컴포넌트를 작성하는 데 사용되는 툴을 개발할 때 이용하도록 만들어졌는데,
    언제부턴가 본래 목적보다는 자바 코드의 메타정보를 데이터로 활용하는 스타일의 프로그래밍 방식에 더 많이 활용되고 있다.
    이런 변화로 인해 등장한 것이 어노테이션이다.
    기존의 클래스, 인터페이스, 필드 메서드 등은 그 자체로 실행이 가능하고, 상속하거나 참조하거나 호출하는 방식 등으로 직접 이용할 수 있다.
    그러나 어노테이션은 옵션에 따라 컴파일된 클래스에 존재하거나 어플리케이션이 동작할 때 메모리에 로딩되기도 하지만
    자바가 실행하는 데 직접 참여하지 못한다.
    리플렉션 API 를 이용해 어노테이션의 메타정보를 조회하고, 어노테이션 내에 설정된 값을 가져와 참고하는 방법이 전부다.
    어노테이션 자체가 클래스의 타입에 영향을 주지도 못하고, 일반 코드에서 활용되지도 못하기 때문에 일반적인 객체지향 프로그래밍 스타일의
    코드나 패턴 등에 적용할 수도 없다.
    이런 차이점을 두고도 스프링은 어노테이션의 적극적인 활용에 앞장서왔다.
    어노테이션은 프레임워크가 참조하는 메타정보로 사용되기에 여러 가지 유리한 점이 많다.
    
    어노테이션은 정의하기에 따라서 타입, 필드, 메서드, 파라미터, 생성자, 로컬 변수의 한군데 이상 적용 가능하다.
    어노테이션이 부여된 클래스의 패키지, 클래스 이름, 접근 제한자, 상속한 클래스나 구현 인터페이스가 무엇인지 알 수 있다.
    동일한 정보를 XML 로 표현하려면 모든 내용을 명시적으로 나타내야 한다.
    리팩토링에서도 많은 차이점이 드러난다.
    XML 은 패키지나 클래스 정보 등이 단순 텍스트로 작성되어 있어서 리팩토링을 할 때 번거롭고 안전하지 못하다.
    
    XML 과 비교하는 어노테이션의 단점은 XML 은 어느 환경에서나 손쉽게 편집이 가능하고 변경되더라도 다시 빌드를 거칠 필요가 없지만,
    어노테이션은 자바 코드에 존재하므로 변경할 때마다 매번 클래스를 새로 컴파일 해줘야 한다.
    자바 개발의 흐름은 점차 어노테이션으로 대체하는 쪽으로 향하고 있다.
    
    어노테이션 같은 메타정보를 활용하는 프로그래밍 방식은 미리 약속한 규칙 또는 관례를 따라서 프로그램이 동작하도록
    만드는 프로그래밍 스타일을 적극적으로 포용하게 만들어왔다.
    미리 정의한 규칙을 따라서 프레임워크가 작업을 수행하고 이런 방식은 자바 코드로 모든 작업 과정을 직접 표현했을 떄에 비해서
    작성해야 할 내용이 줄어든다는 장점이 있다.
    하지만 정책을 기억 못하거나 잘못 알고 있을 경우 의도한 대로 동작하지 않는 코드가 만들어질 수 있다.
    
    어노테이션 사용
    @Bean
        <bean> 으로 정의된 DI 정보는 자바 코드, 특별히 @Bean 이 붙은 메서드와 거의 1:1 로 매핑된다.
        @Bean 은 @Configuration 이 붙은 DI 설정용 클래스에서 주로 사용되는 것으로,
        메서드를 이용해서 빈 오브젝트의 생성과 의존관계 주입을 직접 자바 코드로 작성할 수 있게 해준다.
    @Autowired
        자동와이어링 기법을 이용해서 조건에 맞는 빈을 찾아 자동으로 수정자 메서드나 필드에 넣어준다.
    @Component
        @Component 가 붙은 클래스는 빈 스캐너를 통해 자동으로 빈으로 등록된다.
        정확히는 @Component 또는 @Component 를 메타 어노테이션으로 갖고 있는 
        어노테이션이 붙은 클래스가 자동 빈 등록 대상이 된다.
    @Repository
        DAO 빈을 자동 등록 대상으로 만들 때 사용할 수 있게 @Repository 어노테이션을 제공한다.
    @Import
        자바 클래스로 된 설정정보를 가져올 때 @Import 어노테이션을 사용한다.
    @Profile, @ActiveProfiles
        환경에 따라 빈 설정정보가 달라져야 하는 경우에 파일을 여러 개로 쪼개고 간단한 설정정보를 제공할 때
        @Profile 어노테이션을 클래스 레벨에 부여하고 이름을 넣어준다.
        @ActiveProfile 어노테이션에 부여한 이름이 담긴 @Profile 어노테이션이 부여된 클래스를 활성시킨다.
        @Profile 이 붙은 설정 클래스는 현재 컨테이너의 활성 프로파일 목록에 자신의 프로파일 이름이
        들어있지 않으면 무시된다.
    @PropertySource
        스프링에서 빈 설정 작업에 필요한 프로퍼티 정보를 제공해준다.
        특정 파일에서 프로퍼티 값을 가져오기 위해 프로퍼티 소스를 등록해줄 때 
        @PropertySource 어노테이션을 이용한다.
    @Value
        프로퍼티 소스로부터 가져온 값을 @Value 어노테이션이 붙어있는 필드에 주입해준다.
        PropertySourcesPlaceholderConfigurer 클래스를 static 으로 정의해줘야함 ( 빈 후처리기로 사용됨 )
    @Enable*
        커스텀된 어노테이션인데 @Import 어노테이션으로 필요한 설정 값을 묶어 @Enable~~ 어노테이션으로 정의하여 사용
        e.g ) @Import(value=SqlServiceContext.class)
              public @interface EnableSqlService {}
        
#### 8-1 스프링의 정의
###### 정리
    스프링이란 3. 자바 엔터프라이즈 개발을 편하게 해주는 4. 오픈소스 2. 경량급 1. 애플리케이션 프레임워크
    애플리케이션 프레임워크 : 스프링의 일차적인 존재 목적은 핵심 기술에 담긴 프로그래밍 모델을 일관되게 적용해서 
    엔터프라이즈 애플리케이션 전 계층과 전 영역에 전략과 기능을 제공해줌으로써 애플리케이션을 편리하게 개발하게 해주는 것
    경량급 : 가볍고 단순한 환경에서도 복잡한 EJB 와 고가의 WAS 를 갖춰야만 가능했던
    엔터프라이즈 개발의 고급 기술을 대부분 사용할 수 있다는 것
    자바 엔터프라이즈 개발을 편하게 : 엔터프라이즈 개발에서 필연적으로 요구되는 기술적인 요구를 충족하면서도
    개발을 복잡하게 만들지 않는다는 점
    오픈소스 : 개발에 영향을 줄 수 있는 의견 제시나 패치 제공, 버그 신고, 공개적인 토론 등이 가능함

#### 8-2 스프링의 목적
###### 정리
    스프링은 더더욱 그 목표를 분명히 알고 사용하지 않으면 그 가치를 제대로 얻기 힘들다.
    스프링을 사용하기는 해도 스프링이 주는 혜택을 전혀 누리지 못하고 오히려 사용하지 않느니만 못한 경우도 적지 않다.
    
    스프링은 자바 엔터프라이즈 시스템 개발의 복잡함을 해소할 수 있게 해주는 장점으로 사람들의 환영을 받았다
    스프링 등장 전 자바 엔터프라이즈 시스템은 비즈니스 로직과 엔터프라이즈 기술의 복잡함이 한데 얽혀있었다.
    예를 들어, XML 파싱, 캐시 조회, DB 접근, JDBC 를 통한 데이터 변환, 파일 시스템 사용, 트랜잭션 사용 등
    비즈니스 로직을 구현하기도 벅찰때 엔터프라이즈 기술을 정의하고 사용해야 했다.
    
    스프링 전 등장한 EJB 도 이런 문제점을 해결하기 위해 등장했다.
    이런 문제를 해결하기 위해 여러 서비스를 제공했지만, EJB 라는 틀 안에서 자바 코드를 만들게 강제함으로써
    자바 언어가 갖고있던 장점마저 사라지게 만들었다. 결국 객체지향적인 특성을 잃어버려 개발자에게 점점 외면당했다.
    
    스프링은 이런 EJB 의 문제점을 교훈으로 기술과 관련된 코드나 규약 등이 코드에 등장하는 침투적인 기술이 아닌
    기술의 적용 사실이 코드에 직접 반영되지 않지만 어딘가에서 기술에 필요한 작업을 해주는 비 침투적 기술을 적용했다.
    기술적인 복잡함과 비즈니스 로직을 깔끔하게 분리하면서 스프링 스스로가 애플리케이션 코드에 불필요하게 나타나지 않도록 하는 것이다.
    
    엔터프라이즈 기술에 대한 일관성 없는 접근방식과 특정환경에 종속적인 문제점을 해결하기 위해
    스프링은 서비스 추상화를 앞세워 기술적인 복잡함을 추상화를 통해 로우 레벨의 기술 구현 부분과 기술을 사용하는 인터페이스를 분리하고,
    환경과 세부 기술에 독립적인 접근 인터페이스를 제공했다.
    또, 기술적인 처리를 담당하는 코드와 성격이 다른 코드에 섞여서 사용되는 경우를 해결하기 위해
    스프링은 AOP 를 통해 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 깔끔하게 분리해서 별도의 모듈로 관리하게 해줬다.
    엔터프라이즈 기술과 비즈니스 로직이 지저분하게 얽히거나, 기술적인 코드가 중복돼서 사용되는 문제점도 해결되었다.
    
    기술과 비즈니스 로직의 복잡함을 해결하는 데 스프링이 공통적으로 사용하는 도구는 "객체지향"이다.
    객체지향 설계와 프로그밍을 가능하게 해주는 자바 언어의 장점을 취하지 못하게 하면서,
    특정 기술의 스펙에 종속된 설계 방식을 강요했다는 점에 불만을 갖고 "기본으로 돌아가자" 라는 취지로
    객체지향의 설계 기법을 잘 적용할 수 있는 구조를 만들기 위해 DI 같은 유용한 기술을 편하게 적용하도록
    도와주는 것이 스프링의 기본 전략이다.
    
    스프링을 사용하고 DI 를 적용했다고 하지만, 기계적인 방법으로 항상 사용하는 틀에 박힌 구조의 빈만 정의하고
    나머지 코드에는 DI 를 적용해볼 생각조차 안 한다면 DI 를 잘못 사용하고 있는 것이다.
    왜 스프링이 힘들게 비즈니스 로직 자체를 기술적인 코드와 특정 기술의 스펙이 침범하지 않는 코드로 만들어주는 데
    그토록 힘을 썼을 까 생각해보자.
    순수한 비즈니스 로직만을 담고 있는 코드에는 객체지향 분석과 설계에서 나온 도메인 모델을 쉽게 적용할 수 있기 때문이다.
    모든 스프링의 기술과 전략은 객체지향이라는 자바 언어가 가진 강력한 도구를 극대화해서 사용할 수 있도록 돕는것이다.
    "스프링은 단지 거들 뿐이다."
    유연하게 대응할 수 있는 애플리케이션을 만드는 것은
    객체지향을 잘 활용해서 복잡한 문제를 풀어나갈 줄 아는 개발자의 능력에 달려있다.
     
#### 1-1
###### 코드 추가
###### gradle 추가
###### 문제점
###### 정리