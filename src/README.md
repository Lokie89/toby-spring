#### 1-1 초난감 DAO
###### 코드 추가
    1. add, get 두개의 메소드 생성
    2. add, get 메소드를 검증하기 위한 테스트 코드 작성
###### gradle 추가    
    mysql 연결
    compile group: 'mysql', name: 'mysql-connector-java', version: '8.0.15'
###### 문제점
    Windows Intellij 콘솔 창에 한글이 깨져서 나옴
        - JetBrains / bin / vm.options 파일 둘다 -Dfile.encoding=UTF-8 추가
        - intellij settings / File Encodings 세 항목 UTF-8로 변경
        - intellij settings / Edit Custom VM options -Dfile.encoding=UTF-8 추가
        - 재부팅
###### 정리
    코드의 기능을 검증하고자 할 때는 오브젝트 스스로 자신을 검증하도록 만들기
    
#### 1-2 DAO 의 분리
###### 코드 추가
    1. Connection 을 가져오는 중복된 코드 분리
    2. Connection 을 상속을 통해 서브클래스로 분리
    3. UserDao 의 getConnection() 기능을 확장
###### 문제점
    상속을 통해 관심이 다른 기능을 분리하고, 필요에 따라 다양한 변신이 가능하도록
    확장성도 줬지만 여전히 상속관계는 두 가지 다른 관심사에대해 긴밀한 결합을 허용한다.
    슈퍼클래스의 내부 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있음.
###### 정리
    개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 
    "미래의 변화를 어떻게 대비" 할 것인가.
    분리와 확장을 고려한 설계
    
    관심사의 분리
        관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고,
        관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리
    
    템플릿 메소드 패턴
        슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를
        추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤
        서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용
    
    팩토리 메소드 패턴
        서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것

#### 1-3 DAO 의 확장
###### 코드 추가
    1. Connection 을 가져오는 독립적 클래스 SimpleConnectionMaker 추가
        - N사와 D 사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션 기능 사용 불가능
    2. 인터페이스 도입 ConnectionMaker 추가
    3. ConnectionMaker 구현 NConnectionMaker, DConnectionMaker 클래스 추가
        ( 2 - 3 전략패턴 적용 )
    4. UserDao 에 ConnectionMaker 필드 추가, 생성자 주입
    5. 클라이언트 ( UserDaoTest ) ConnectionMaker 생성 후 주입
###### 문제점 
    어떤 ConnectionMaker 구현체를 사용할 것인지를 결정하는 기능을 UserDaoTest 에서 가지고 있음
###### 정리
    클래스 사이의 의존 관계는 만들지 말고,
    오브젝트 사이의 다이나믹한 의존 관계를 만들어라.
    
    개방 폐쇄 원칙
        클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
        
    높은 응집도와 낮은 결합도
        응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것
        결합도가 낮다는 것은 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는
        다른 오브젝트에게 변화를 요구하는 정도가 낮다는 것
        
    전략 패턴
        자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해
        외부에 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라
        바꿔서 사용할 수 있게 하는 디자인 패턴
#### 1-4 제어의 역전 ( IoC )
###### 코드 추가
    1. UserDao 생성 책임을 갖는 DaoFactory 클래스
###### 정리
    팩토리
        객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것
        오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과
        책임을 깔끔하게 분리하려는 목적
        
    제어의 역전 
        프로그램의 제어 흐름 구조가 뒤바뀌는 것
        제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않음
        생성하지도 않음, 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없음
        모든 제어 권한을 자신이 아닌 다른 대상에게 위임

#### 1-5 스프링의 IoC
###### 코드 추가
    1. DaoFactory class @Configuration 등록
    2. DaoFactory class userDaoJdbc, connectionMaker @Bean 등록
    3. UserDaoTest ApplicationContext 에서 위에서 등록한 userDaoJdbc 추출 (getBean())
###### gradle 추가
    compile group: 'org.springframework', name: 'spring-core', version: '5.2.4.RELEASE'
    @Configuration, @Bean, ApplicationContext 사용
    compile group: 'org.springframework', name: 'spring-context', version: '5.2.4.RELEASE'
###### 정리
    빈
        스프링이 직접 IoC 방식으로 생성과 제어를 관리하는 오브젝트
    빈 팩토리
        스프링의 IoC 를 담당하는 핵심 컨테이너
    애플리케이션 컨텍스트
        빈 팩토리에 스프링이 제공하는 각종 부가 서비스를 추가로 제공하는 IoC 컨테이너
    설정정보
        애플리케이션 컨텍스트가 IoC 를 적용하기 위해 사용하는 메타정보

#### 1-6 싱글톤 레지스트리와 오브젝트 스코프
###### 정리
    ApplicationContext 에서 getBean() 을 호출하여 얻은 오브젝트는 동일하다.
    
    대규모의 엔터프라이즈 서버 환경에서 수십 수백번씩 브라우저나 다른 시스템으로부터
    요청을 받아 처리하기 위해서 매번 새로운 오브젝트를 만들면 서버에 과부하가 걸린다.
    그래서 클래스당 하나의 오브젝트만 만들어 두고 사용자의 요청을 담당하는 여러 스레드에서
    하나의 오브젝트를 공유해 동시에 사용한다.
    
    이런 디자인 패턴을 싱글톤 패턴이라 하는데, 이 디자인 패턴에는 한계점이 있다.
    1. private 생성자를 갖고 있기 때문에 상속이 불가능하다.
    2. 테스트하기 어렵다.
    3. 클래스 로더를 어떻게 구성하고 있느냐에 따라서 하나 이상의 오브젝트가 만들어질수 있다.
    4. 어떤 클라이언트가 사용할지 모르기때문에 대부분 전역 상태로 사용된다.
    
    스프링은 서버환경에서 싱글톤이 만들어져 서비스를 제공하는 것은 지지하지만,
    자바의 기본적인 싱글톤 패턴 구형 방식은 위처럼 여러가지 단점이 있기 때문에
    직접 싱글톤 형태의 오브젝트를 만들고 관리하는 "싱글톤 레지스트리" 라는 기능을 제공한다.
    
    싱글톤 레지스트리는 오브젝트 생성에 관한 모든 권한을 가진 애플리케이션 컨텍스트 덕분에
    private 생성자가 아닌 평범한 자바클래스를 싱글톤으로 활용할 수 있게 해준다.
    
    멀티 스레드 환경에서 주의할 점
    싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는
    상태정보를 내부에 갖고 있지 않은 "무상태 방식"으로 만들어져야 한다.
    
    스코프
        스프링이 관리하는 빈이 생성되고 존재하고 적용되는 범위
        
    싱글톤 스코프 : 컨테이너 내에 한 개의 오브젝트만 만들어짐
    프로토타입 스코프 : 빈을 요청할 때마다 새로운 오브젝트를 만들어줌
    요청 스코프 : 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성
    세션 스코프 : 웹의 세션과 스코프가 유사함

#### 1-7 의존관계 주입 ( DI )
###### 코드 추가
    1. ConnectionMaker 생성 될 때마다 카운팅 해주는 CountingConnectionMaker 추가
    2. CountingConnectionMaker 를 UserDao 에 DI 해주는 CountingDaoFactory 추가
    3. 의존관계 검색을 이용한 UserDaoCountingConnectionTest 추가  
###### 정리
    의존한다는 건 의존 대상, 즉 오브젝트가 변하면 다른 오브젝트에 영향을 끼친다는 것
    
    인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는
    느슨해지면서 변화에 영향을 덜 받는 상태가 됨
    
    인터페이스를 통하여 의존관계 성립, 즉 런타임 시점의 의존관계를 결정하고 만들려면
    제3의 존재가 필요함
    
    의존관계 검색 ( ApplicationContext getBean() ) 과 
    의존관계 주입 ( 외부에서 오브젝트를 주입 ) 의 차이점
    의존관계 검색 방식에서는 검색하는 오브젝트 자신이 스프링의 빈 일 필요가 없다.
    의존관계 주입 방식에서는 검색하는 오브젝트 자신이 스프링의 빈 이어야만 한다.
    오브젝트를 주입해주려면 생성과 초기화 권한을 갖고 있어야 하기 때문
    
    의존관계 주입의 장점은 관심사의 분리를 통해 얻어지는 높은 응집도에서 나온다
      
#### 1-8 XML 을 이용한 설정
###### 코드 추가
    1. DaoFactory 를 대체할 applicationContext.xml 파일 추가
    2. UserDao 의존 오브젝트 ConnectionMaker -> DataSource 로 변경
    3. applicationContext.xml 파일의 DataSource 프로퍼티 추가
###### gradle 추가
    SimpleDriverDataSource 사용 ( jdbc 드라이버 클래스, jdbc url, id, pwd 등의 수정자 )
    compile group: 'org.springframework', name: 'spring-jdbc', version: '5.2.4.RELEASE'
###### 정리
    범용 DI 컨테이너를 사용하려면 오브젝트 사이의 의존정보를 일일이 자바 코드로 만들긴 번거롭다.
    스프링은 다양한 방법으로 DI 의존관계 설정정보를 만들 수 있다.
    
    xml 파일에서 DI 의존관계를 설정할 때 사용 하는 <bean> 태그 안에서 property 설정은
    <property> 태그를 통하여 할 수 있음. <property> 태그의 name 애트리뷰트는 DI 에 사용할
    수정자 메소드의 프로퍼티 이름, ref 애트리뷰트는 주입할 오브젝트를 정의한 빈의 id 이다. 

    <property> 태그의 애트리뷰트 중 value 값은 스트링 값을 사용한다.
    그러나 다른 타입의 형태도 주입이 가능한데, 이는 스프링이 프로퍼티의 값을, 
    "수정자 메소드의 파라미터 타입을 참고로 해서 적절한 형태로 변환해주기 때문"

    xml 파일에서 정의한 의존관계 정보를 이용하는 작업에는 GenericXmlApllicationContext 를 사용
    
#### 2-1 UserDaoTest 다시 보기
###### 정리
    테스트는 필수이며 작은 테스트 부터 큰 테스트 까지 모두 해야함
    
#### 2-2 UserDaoTest 개선
###### 코드 추가
    1. UserDaoTest 에서 확인 하는 코드를 단순히 필드를 보여주는 것만이 아닌
       실제 입력했던 필드와 같은 값인지 확인
    2. JUnit 프레임 워크 사용하여 테스트 코드 작성
###### 정리
    테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것
    JUnit 프레임 워크의 조건
        메소드가 public 으로 선언
        메소드에 @Test 라는 어노테이션 붙여줄 것

#### 2-3 개발자를 위한 테스팅 프레임워크 JUnit
###### 코드 추가
    1. UserDao 에 메소드 추가
    2. UserDaoTest 에 추가한 메소드의 테스트 추가
    3. UserDaoTest 에 예외 발생 테스트 추가
    4. UserDaoTest 의 중복 코드 취합 @Before 어노테이션으로 묶음
###### 정리
    테스트하기 전에 테스트 실행에 문제가 되지 않는 상태를 만들어주는 편이 좋다.
    "항상 네거티브 테스트를 먼저 만들어라."
    
    테스트 주도 개발 TDD
    만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록
    테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발방법
    "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다."

    JUnit 테스트 수행 방식
    1. @Test, public, void, no parameter 메소드 찾는다.
    2. 오브젝트를 만든다
    3. @Before가 붙은 메소드 실행
    4. @Test 메소드 호출 테스트 결과 저장
    5. @After가 붙은 메소드 실행
    6. 다른 테스트에 대해 2~5번 반복
    7. 모든 테스트의 결과 리턴
    
    각 테스트를 진행할 때마다 테스트 클래스의 오브젝트를 새로 생성,
    각 테스트가 서로 영향을 주지않고 독립적으로 실행됨을 보장해주기 위함
    
    픽스처
        테스트를 수행하는데 필요한 정보나 오브젝트

#### 2-4 스프링 테스트 적용
###### 코드 추가
    1. UserDaoTest 의 RunWith 파라미터를 SpringJUnit4ClassRunner.class 로 변경
    2. @ContextConfiguration 추가, 파라미터로 applicationContext.xml 지정
    3. ApplicationContext @Autowired 통해 DI
    4. UserDao @Autowired 통해 DI
    5. testtobyspring database 추가
    6. test-applicationContext.xml 추가
    7. UserDaoTest @ContextConfiguration 파라미터 수정
###### gradle 추가
    SpringJUnit4ClassRunner class, @ContextConfiguration
    testCompile group: 'org.springframework', name: 'spring-test', version: '5.2.4.RELEASE'
###### 정리
    스프링 컨테이너에서 생성되는 오브젝트는 싱글톤 방식으로 생성되기 때문에 하나의 어플리케이션 
    컨텍스트가 만들어져 사용된다. 그러나 JUnit 테스트 메소드를 실행 할때마다 생성되는 UserDaoTest의 오브젝트는 
    매번 다른 주소값을 갖는 새로운 테스트 오브젝트를 생성한다.
    
    @Autowired 가 붙은 인스턴스 변수가 있으면, 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다.
    또, 타입으로 가져올 빈 하나를 선택할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다.
    변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.
    
    DI 를 적용할 때 인터페이스를 둬야 하는 이유
    1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
       당장 클래스의 변경이 없다고 하더라도 변경이 필요한 상황이 닥쳤을 때 수정에 들어가는 시간과 비용의 부담을 줄일수 있다.
    2. 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면
       다른 차원의 서비스 기능을 도입할 수 있기 때문이다.
       새로운 기능을 넣기 위해 기존 코드는 수정할 필요가 없다.
    3. 테스트 때문이다.
       효율적인 테스트를 손쉽게 만들기 위해서 DI를 적용해야 한다. 
    
    DataSource 같은 경우에는 실제 운영 DB와 개발용 ( TEST ) DB를 다르게 가지고 가는 방법이 좋다.
    따라서 개발용 DB 를 따로 만들고 해당 테스트 클래스 또는 메소드에 @DirtiesContext 를 사용한다.
    
    @DirtiesContext 는 해당 클래스 또는 메소드의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다.
    이 애노테이션이 붙은 테스트 클래스 또는 메소드에는 애플리케이션 컨텍스트 공유를 허용하지 않는다.
    
    @DirtiesContext 사용 후 코드 내에 수동으로 DI 를 설정하는 것보단
    따로 xml 파일을 하나 더 생성해 해당 테스트 클래스에 적용해주는 것이 더 좋은 방법이다.
     
#### 2-5 학습 테스트로 배우는 스프링
###### 코드 추가
    1. JUnit 테스트 시 생성되는 오브젝트에 대한 테스트 추가
###### 정리
    학습테스트
        자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서 테스트를 작성
    장점
    1. 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
    2. 학습 테스트 코드를 개발 중에 참고할 수 있다.
    3. 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
    4. 테스트 작성에 대한 좋은 훈련이 된다.
    5. 새로운 기술을 공부하는 과정이 즐거워진다
    
    버그테스트
        코드에 오류가 있을 때 그 오류를 가장 잘 드러낼줄 수 있는 테스트
    장점
    1. 테스트의 완성도를 높여준다.
    2. 버그의 내용을 명확하게 분석하게 해준다.
    3. 기술적인 문제를 해결하는 데 도움이 된다.    

#### 3-1 다시 보는 초난감 DAO
###### 코드 추가
    1. 예외 발생 시에도 리소스를 반환하도록 UserDao 의 deleteAll 메소드 수정
    2. 위와 같이 UserDao 의 getCount 메소드 수정
###### 정리
    제한적인 리소스를 공유해 사용하는 서버에서 "예외처리"는 지켜야 할 원칙이다.

#### 3-2 변하는 것과 변하지 않는 것
###### 코드 추가
    1. 전략 패턴을 사용하기 위한 StatementStrategy interface 추가
    2. StatementStrategy interface 구현한 DeleteAllStatement class 추가
    3. StatementStrategy interface 를 매개 변수로 받는 
       try catch finally 를 분리한 jdbcContextWithStatementStrategy 메소드 구현
    4. UserDao deleteAll 메소드에서 DeleteAllStatement 객체 생성 후 
       jdbcContextWithStatementStrategy 메소드 사용
###### 정리
    템플릿 메소드 패턴
        상속을 통해 기능을 확장해서 사용함
        변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해 둬서
        서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 함
    
    전략 패턴
        확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임
    
    전략 패턴에 따르면 Context 가 어떤 전략을 사용하게 할 것인가는 Context 를 사용하는
    Client 가 결정하는 게 일반적이다. Client 가 구체적인 전략의 하나를 선택하고 
    오브젝트로 만들어서 Context 에 전달하는 것이다. Context 는 전달받은 
    그 Strategy 구현 클래스의 오브젝트를 사용한다.
    
#### 3-3 JDBC 전략 패턴의 최적화
###### 코드 추가
    1. AddStatement 생성하여 기존 UserDao 의 add() 메소드 변경
###### 문제점
    메소드를 해결하기 위해 클래스를 계속 생성함
    e.g ) add() 를 위해 AddStatement, deleteAll() 을 위해 deleteAllStatement 등
    -> 중첩 클래스 사용
###### 정리
    전략 패턴을 사용하기 위해 전략을 구현한 클래스를 생성하기 위한 팁
    매번 클래스를 생성하는 것은 낭비 and 사용처가 유일함 ( 보통 ) 일때
    중첩 클래스 사용
    
    중첩 클래스
        클래스 내부에 정의되는 클래스를 이야기함
        스태틱 클래스와 내부 클래스로 구분
    
    내부 클래스는 멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 내부 클래스,
    메소드 레벨에서 정의되는 로컬 클래스, 이름을 갖지 않는 익명 내부 클래스로 구분된다.
    
#### 3-4 컨텍스트와 DI
###### 코드 추가
    1. UserDao 의 jdbcContextWithStatementStrategy 를 다른 DAO에서도 사용할 수 있도록 JdbcContext 클래스로 분리
    2. 생성된 JdbcContext 에 DataSource 의존관계 설정
    3. 기존에 UserDao 에서 사용하던 jdbcContextWithStatementStrategy 메서드는 JdbcContext 의 메서드로 대체
###### 문제점
    UserDao 는 인터페이스를 거치지 않고 바로 생성된 JdbcContext 를 사용되고 있다.
    이는 클래스 사이의 의존관계가 성립되지 않도록 하는 기존 DI 와는 다른 의존 방법이다.
###### 정리
    스프링의 DI 는 객체의 생성과 관계설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC 개념을 포괄한다.
    
    JdbcContext 를 UserDao 와 DI 구조로 만들어야 할 이유
        1. JdbcContext 가 스프링 컨테이너의 싱글톤 빈이 되기 때문
        2. JdbcContext 가 DI 를 통해 다른 빈 ( DataSource ) 에 의존하기 있기 때문
    
    그러나 인터페이스를 사용하지 않고 JdbcContext 와 UserDao 의 의존관계를 설정한 이유는
    서로 매우 긴밀한 관계를 가지고 강하게 결합되어 있기 때문
    
    인터페이스를 사용하지 않는 클래스 사이의 의존관계를 갖고 스프링의 DI 를 이용하기 위해 빈으로 등록해서 사용하는 방법은
    오브젝트 사이의 실제 의존관계가 설정파일에 명확하게 드러난다는 장점이 있다. 그러나 DI의 근본적인 원칙에 부합하지 않는
    구체적인 클래스와의 관계가 설정에 직접 노출된다는 단점이 있다.
    
    반면에 수동으로 DI 하는 방법은 클라이언트의 내부에서 만들어지고 사용되면서 그 관계를 외부에는 드러내지 않는다는 장점이 있다.
    그러나 여러 오브젝트가 사용하더라도 싱글톤으로 만들 수 없고, DI 작업을 위한 부가적인 코드가 필요하다는 단점이 있다.
    
    .. 
    인터페이스를 사용하지 않는 클래스 ( 강한 결합 ) 간의 의존관계 적용 시
    스프링 컨테이너를 사용하면 설정 파일에 클래스의 대한 정보가 그대로 드러나지만 스프링 컨테이너가 주는 이점 ( 싱글톤 ) 을 사용할 수 있고,
    스프링 컨테이너를 사용하지 않으면 클라이언트에서 은밀히 그 전략을 외부에 감추고 사용할 수 있지만 스프링 컨테이너의 이점 을 사용할 수 없다.

#### 3-5 템플릿과 콜백
###### 코드 추가
    1. 콜백 메서드의 공통 부분 분리 executeSql 메서드 생성
    2. 다른 DAO 에서도 사용할 수 있도록 executeSql JdbcContext 클래스로 이동
    3. 파라미터가 필요한 메서드를 위해 executeSql 가변인자 추가
    
    템플릿/콜백 패턴 예제
    1. 숫자가 들어있는 txt 파일 추가
    2. txt 파일을 읽어서 계산하는 Calculator 추가
    3. 더하는 calcSum 메소드 추가
    4. 반복되는 로직을 수행하는 LineCallback interface 추가
    5. sum, multiply 로직의 다른 부분을 익명 클래스로 구현 ( 템플릿/콜백 패턴 )
    6. LineCallback 인터페이스에 제네릭스 추가
###### 정리
    템플릿 콜백 패턴
        일정한 패턴을 갖는 작업 흐름이 존재하고, 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 전략패턴을 사용한다.
        전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식을 스프링에서는 템플릿/콜백 패턴이라 한다.
        
    템플릿은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미
    콜백은 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 의미
    
    템플릿/콜백 패턴의 콜백은 보통 단일 메소드를 인터페이스를 사용

#### 3-6 스프링의 JdbcTemplate
###### 코드 추가
    1. UserDao 의 JdbcContext 를 스프링의 JdbcTemplate 으로 대체
    2. JdbcTemplate 의 update, query, queryForObject 를 통하여 각 메서드 로직 대체
###### 정리
    스프링의 제공하는 템플릿/콜백 패턴을 적용하는 클래스 JdbcTemplate
    update :
        PreparedStatementCreator 인터페이스의 구현체를 익명 클래스로 구현하여 매개변수로 넣어줌
        jdbcTemplate 이 가지고 있는 dataSource 으로 만들어진 Connection 을 매개 변수로 갖는 
        createPreparedStatement 메서드 실행
        또는 sql 문을 매개 변수로 넣어줌
        매개 변수가 필요한 경우 PreparedStatementCreator 구현체 또는 sql 문 뒤에 차례로 넣어줌
        return 값 없음. 
    query :
        return 값이 필요한 경우,
        PreparedStatementCreator 구현체와, ResultSetExtractor 구현체를 파라미터로 받음
        PreparedStatementCreator 후 나온 결과 값을 ResultSetExtractor 의 extractData 메서드
        파라미터 ResultSet 으로 넘겨줌
    queryForObject :
        query 파라미터 중 ResultSetExtractor 대신 RowMapper 사용
        차이점은 ResultSetExtractor 는 ResultSet 을 한 번 전달받아 추출 작업을 진행하는데 반해
        RowMapper 는 ResultSet 의 로우 하나를 매핑하기 위해 사용되기 때문에 여러번 호출될 수 있다.
        SQL을 실행해서 받은 로우의 개수가 하나가 아니라면 예외를 던진다.

    테스트를 작성할 때 항상 네거티브 테스트부터 만들 것
    
#### 4-1 사라진 SQLException
###### 정리
    예외 처리 문제
        예외가 발생하면 그것을 catch 블록을 써서 잡아내는 것까지는 좋은데 아무것도 하지 않고
        별문제 없는 것처럼 넘어가 버린느건 정말 위험한 일이다.
        모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다.
    
    Error
        시스템에 뭔가 비정상적인 상황이 발생했을 경우 사용된다. 대응방법이 따로 없기 때문에 신경 쓰지 않아도 된다.
    체크 예외
        발생 가능한 예외적인 상황에서 던져질 가능성이 있는 대부분 예외들
        반드시 예외 처리하는 코드를 함께 작성해야 한다. 그렇지 않으면 컴파일 에러가 발생
    언체크 예외 ( RuntimeException )
        주로 프로그램의 오류가 있을 때 발생하도록 의도된 것
        
    예외 처리 방법
        1. 예외 복구
            예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
            try catch
        2. 예외처리 회피
            예외처리를 자신이 담당하지 않고 자신을 호출한 쪽에 던져버리는 것
            throw
        3. 예외 전환
            발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던지는 것
            주로 의미를 분명하게 해줄 수 있는 예외로 바꾸거나, 체크 예외를 언체크 예외로 바꾸는 경우 사용
            catch another exception throw
    
    애플리케이션 예외
        시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고,
        반드시 catch 해서 무엇인가 조치를 취하도록 요구하는 예외
    
    사라진 SQLException
        대부분의 SQLException 은 복구가 불가능하다.
        따라서 스프링의 JdbcTemplate 템플릿과 콜백 안에서 발생하는 모든 SQLException 을 런타임 예외인
        DataAccessException 으로 포장해서 던져주고 있다.
        
#### 4-2 예외 전환
###### 코드 추가
    1. DB에 독립적인 UserDao 생성을 위한 interface 생성 
        ( Jdbc를 사용하는 UserDao 를 UserDaoJdbc 로 변경 UserDao interface 생성 ) 
###### 정리
    DataAccessException 은 SQLException 에 담긴 다루기 힘든 상세한 예외 정보를 의미 있고
    일관성 있는 예외로 전환해서 추상화해주려는 용도로 쓰인다.
    
    JDBC 의 한계
        1. 대부분의 DB는 표준을 따르지 않는 비표준 문법과 기능을 제공한다.
           이에 따라 작성된 비표준 SQL 은 DAO 코드에 들어가고 해당 DAO 는 특정 DB에 종속적인 코드가 되고 만다.
        2. DB 마다 SQL 만 다른 것이 아니라 에러의 종류와 원인도 제각각이다.
           DB 마다 다른 에러 코드를 대신할 수 있도록 XOPEN SQL 스펙에 정의된 SQL 상태 코드를 따르게 되어있지만,
           DB 의 JDBC 드라이버에서 SQLException 에 담을 상태 코드를 정확하게 만들어 주지 않는다.
        따라서 SQLException 에 담긴 SQL 상태 코드는 신뢰할 수 없고, DB 업체별로 만들어 유지해 오고 있는
        DB 전용 에러 코드가 더 정확한 정보
        
    스프링은 이런 JDBC 의 한계를 극복하기 위해 DataAccessException 이라는 런타임 예외를 정의하고
    데이터 엑세스 작업 중에 발생할 수 있는 예외상황을 수십 가지 예외로 분류하고 이를 추상화해 정의한
    다양한 예외 클래스를 제공한다.
    
    스프링에서는 DB 별 에러 코드를 분류해서 스프링이 정의한 예외 클래스와 매핑해놓은
    에러 코드 매핑 정보 테이블을 만들어두고 이를 이용한다.
    
    따라서 JdbcTemplate 을 이용한다면 JDBC에서 발생하는 DB 관련 예외는 거의 신경 쓰지 않아도 된다.
        
#### 5-1 사용자 레벨 관리 기능 추가
###### 코드 추가
    1. 사용자 레벨을 관리할 Level enum 추가
    2. level, login recommend 항목 추가된 테이블에 맞게 메소드 등 변경
    3. UserService 추가
    4. UserServiceTest 추가
    5. UserTest 추가
    6. 업그레이드 정책을 담은 UserLevelUpgradePolicy interface 추가
    7. UserLevelUpgradePolicy 구현 클래스 GeneralUserLevelUpgradePolicy, EventUserLevelUpgradePolicy 추가
###### 정리
    작성된 코드를 살펴볼 때는 다음과 같은 질문을 해본다.
        1. 코드에 중복된 부분은 없는가?
        2. 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
        3. 코드가 자신이 있어야 할 자리에 있는가?
        4. 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

    객체지향적 코드
        내부정보를 다루는 자신의 책임에 충실한 기능을 갖고 있으면서 필요가 생기면 이런 작업을 수행해달라고 서로 요청하는 구조
        각자 자기 책임에 충실한 작업만 하고 있으니 코드를 이해하기도 쉬움
        변경이 필요할 때 어디를 수정해야 할지도 쉽게 알 수 있음
        잘못된 요청이나 작업을 시도했을 때 이를 확인하고 예외를 던져줄 준비도 다 되어 있음
        각각을 독립적으로 테스트하도록 만들면 테스트 코드도 단순해짐
        
        "객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다."
        
        오브젝트에게 데이터를 요구하지 말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이다.
        단순히 '이렇게 만들면 코드를 더 이해하기 쉽고 변화에 대응하기가 편하구나' 라고 생각해도 됨.
        
#### 5-2 트랜잭션 서비스 추상화-1
###### 코드 추가
    1. 트랜잭션 테스트용 UserSrvice 대역 TestUserService 추가
    2. 예외 상황을 위한 TestUserServiceException 추가
    3. UserService upgradeLevels 메서드에 트랜잭션 동기화 적용
###### 정리
    DB 는 그 자체로 완벽한 트랜잭션을 지원한다.
    그러나 다중 SQL 이 사용되는 작업을 하나의 트랜잭션으로 취급해야 하는 경우 트랜잭션으로 묶어야 한다
    
    두 가지 작업이 하나의 트랜잭션이 되려면, 두번째 SQL이 성공적으로 DB 에서 수행되기 전에 문제가 발생할 경우에는
    앞에서 처리한 SQL 작업도 취소 ( 트랜잭션 롤백 )
    반대로 여러 개의 SQL 을 하나의 트랜잭션으로 처리하는 경우에 모든 SQL 수행 작업이 다 성공적으로 마무리 됐다고
    DB 에 알려줘서 작업을 확정 ( 트랜잭션 커밋 )
    
    트랜잭션의 시작을 선언하고 트랜잭션을 종료 ( 롤백 or 커밋 ) 하는 작업을 트랜잭션의 경계 설정 이라고 한다.
    
    여러 번 DB에 업데이트를 해야 하는 작업을 하나의 트랜잭션으로 만들려면
    그 작업이 진행되는 동안 DB 커넥션도 하나만 사용돼야 한다.
    
    트랜잭션 처리를 위해 작업을 진행 하기 전 생성한 Connection 오브젝트를 전달하여 사용할 수 있다.
    그러나 이 방법의 문제점은 
    1. JdbcTemplate 을 더 이상 활용할 수 없다
    2. 트랜잭션 처리할 모든 메서드에 Connection 파라미터가 추가
    3. Connection 파라미터가 인터페이스 메소드에 추가되면 데이터 엑세스 기술에 독립적일 수 없음
    4. 테스트 코드에서도 직접 Connection 오브젝트를 만들어야 함
    등이 생긴다.
    
    그래서 트랜잭션 동기화 방법을 사용한다.
    트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고
    이후에 호출되는 메서드에서는 저장된 Connection 을 가져다가 사용하게 하는 것
    
    스프링의 트랜잭션 동기화
    스프링이 제공하는 트랜잭션 동기화 관리 클래스는 TransactionSynchronizationManager 이며
    1. 이를 이용해 트랜잭션 동기화 작업을 초기화 한다.
    2. DataSourceUtils 에서 제공하는 getConnection() 메서드를 통해 DB 커넥션 생성한다.
       DataSourceUtils 의 getConnection 메서드는 트랜잭션 동기화에 사용하도록 저장소에 바인딩 해줌
    3. 해당 작업을 진행한다.
    4-1. 작업을 정상적으로 마치면 트랜잭션을 커밋한다.
    4-2. 예외가 발생하면 트랜잭션을 롤백한다.
    5. 커넥션을 닫고 동기화 작업을 중단한다.
    
    JdbcTemplate 은 영리하게 동작하도록 설계되어 있어서 트랜잭션이 굳이 필요 없다면 바로 호출해서 사용하고
    트랜잭션을 만들고 이를 관리할 필요가 잇따면 미리 DB 커넥션을 생성한 다음 트랜잭션 동기화를 해주고 사용하면 된다.
     

#### 5-2 트랜잭션 서비스 추상화-2
###### 코드 추가
    1. 스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스 PlatformTransactionManager 사용
    2. PlatformTransactionManager DI 적용
###### 정리
    하나의 트랜잭션 안에서 여러 개의 DB 에 데이터를 넣는 작업을 해야 할 필요가 있을 때
    JDBC 의 Connection 을 이용한 트랜잭션 방식 ( 로컬 트랜잭션 ) 으로는 하나의 DB Connection 에 종속되기 떄문에 불가함
    별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 글로벌 트랜잭션 방식을 사용
    스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공
    PlatformTransactionManager 인터페이스 사용하여
    JTA 는 JTATransactionManager
    Hibernate 는 HibernateTransactionManager
    JPA 는 JPATransactionManager 를 사용하여
    트랜잭션 경계설정을 만듬
    
    어떤 클래스든 스프링의 빈으로 등록할 떄 먼저 검토해야 할 것은 점
    싱글톤으로 만들어져 여러 스레드에서 동시에 사용해도 괜찮은가 하는 가
    

#### 5-3 서비스 추상화와 단일 책임 원칙
###### 정리
    서비스 추상화 수평적 분리
    서로 불필요한 영향을 주지 않으면서 독자적으로 확장 가능하도록 만든 것,
    같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리
    
    서비스 추상화 수직적 분리
    애플리케이션의 비즈니스 로직과 그 하위에서 동작하는 로우레벨의 기술인
    아예 다른 계층의 특성을 갖는 코드를 분리
    
    애플리케이션 로직의 종류에 따른 수평적 구분이든, 로직의 기술에 따른 수직적 구분이든,
    모두 결합도 가 낮으며, 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들수 있는 데는
    스프링의 DI 가 중요한 역할을 하고 있다.
    DI 의 가치는 이렇게 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는 데 있다.
    
    단일 책임 원칙
    하나의 모듈은 한 가지 책임을 가져야 한다.
    하나의 모듈이 바뀌는 이유는 한 가지여야 한다.
    
    단일 책임 원칙을 잘 지키고 있다면, 어떤 변경이 필요할 때 수정 대상이 명확해진다.
    단일 책임 원칙을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 이를 DI 로 연결해야 하며,
    그 결과로 단일 책임 원칙뿐 아니라 개방 폐쇄 원칙도 잘 지켜지고, 모듈 간에 결합도가 낮아서
    서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응집도 높은 코드가 나온다.

#### 5-4 메일 서비스 추상화
###### 코드 추가
    1. User email 필드 추가
    2. JavaMail 에 대한 추상화 인터페이스 MailSender 사용
    3. 스프링 DI 적
    4. 테스트용 DummyMailSender 추가
    5. 목 오브젝트 MockMailSender 추가
###### gradle 추가
    Session class 사용
    compile group: 'javax.mail', name: 'mail', version: '1.4.7'
    compile group: 'javax.activation', name: 'activation', version: '1.1.1'
    MailSender, JavaMailSenderImple 사용
    compile group: 'org.springframework', name: 'spring-context-support', version: '5.2.5.RELEASE'
###### 정리
    자바에서 메이ㄹ을 발송할 때는 표준 기술인 JavaMail 을 사용
    그러나 JavaMail 은 확장이나 지원이 불가능하도록 만들어진 악명 높은 표준 API 중 하나
    그래서 스프링에서는 JavaMail 을 사용해 만든 추상화 기능을 가진 인터페이스 제공
    MailSender 라는 이 인터페이스는 SimpleMailMessage 라는 인터페이스를 매개 변수로 받아 발송하는 기능만 가지고 있음
    
    일반적으로 서비스 추사화란 유사하나 사용 방법이 다른 로우레벨의 다양한 기술에 대해 
    추상 인터페이스와 "일관성 있는 접근 방법"을 제공해주는 것을 말함
    
    테스트 대역
    테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게,
    자주 테스트를 실행할 수 있도록 사용하는 오브젝트
    
    테스트 스텁
    테스트 대상 오브젝트의 의존객체로서 존재하면서 테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕는 것
    
    목 오브젝트
    스텁처럼 테스트 오브젝트가 정상적으로 실행되도록 도와주면서, 테스트 오브젝트와 자신의 사이에서
    일어나는 커뮤니케이션 내용을 저장해뒀다가 테스트 결과를 검증하는 데 활용

#### 6-1 트랜잭션 코드의 분리
###### 코드 추가
    1. 비즈니스 로직을 메서드 단위로 분리
    2. UserService 를 UserServiceImpl 로 이름 변경 트랜잭션 기능 제거, UserService interface 추가
    3. 트랜잭션 기능을 담은 UserServiceTx 추가
###### 정리
    보통 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시에 DI 를 이용해
    적용하는 방법을 쓰는 이유는, 일반적으로 구현 클래스를 바꿔가면서 사용하기 위해서다.
    
    트랜잭션을 로직을 분리하는 방법
    트랜잭션을 적용한 로직, 또는 적용하지 않은 로직을 사용하기 위해
    트랜잭션이 적용된 클래스, 트랜잭션이 적용되지 않은 클래스로 나눈다.
    공통 메서드를 추상화 한 인터페이스를 정의하고
    인터페이스를 구현한다
    트랜잭션이 적용된 클래스에서는 메서드를 실행할 때,
    해당 트랜잭션 경계 설정을 수행한 후 DI 받은 인터페이스 구현체의 메서드를 실행한다.
    트랜잭션 적용 오브젝트에서 트랜잭션 경계설정 후 -> 해당 로직 ( DI 받은 인터페이스 구현체 ) -> 트랜잭션 경계설정 해제
    순으로 로직이 실행된다.

#### 6-2 고립된 단위 테스트
###### 코드 추가
    1. 테스트를 위한 MockUserDao 추가
    2. Mokito 프레임워크 사용 하여 목 오브젝트 대체테스트 작성
###### gradle 추가
    Mockito 프레임워크 사용
    testCompile group: 'org.mockito', name: 'mockito-core', version: '3.3.3'
###### 정리
    가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것
    작은 단위의 테스트가 좋은 이유는 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문이다.
    테스트 단위가 작아야 테스트의 의도나 내용이 분명해지고, 만들기도 쉬워진다.
    테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.
    방법은 테스트를 위한 대역을 사용하는 것
    
    의존 오브젝트나 외부 서비스에 의존하지 않는 고립된 테스트 방식으로 만든 오브젝트는 아무리 그 기능이 수행돼도
    그 결과가 DB 등을 통해서 남지 않으니, 작업 결과를 검증하기 힘들다.
    이럴 땐 테스트 대상이 어떤 요청을 했는지를 확인하는 작업이 필요하다.
    주고받은 정보를 저장해뒀다가 테스트의 검증에 사용할 수 있게 하는 목 오브젝트를 만들 필요가 있음.
    
    단위 테스트
    단위 테스트의 단위는 정하기 나름이다. 사용자 관리 기능 전체를 하나의 단위로 볼 수도 있고
    하나의 클래스나 하나의 메서드를 단위로 볼 수도 있다. 중요한 것은 하나의 단위에 초점을 맞춘다는 것이다.
    
    하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고
    필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하도록 테스트를 만든다.
    
    코드를 만들고 나서 오랜 시간이 지난 뒤에 작성하는 테스트는 테스트 대상 코드에 대한 이해가 떨어지기 때문에
    불완전해지기 쉽고 작성하기도 번거롭다.
    코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관이다.
    테스트하기 편하게 만들어진 코드는 깔끔하고 좋은 코드가 될 가능성이 높다.
    
    목 오브젝트 사용
    의존성 없는 테스트를 작성하기 위해 목 오브젝트를 사용하다보면 테스트를 위해 만들어야 할 오브젝트가
    많아질 수 있다. 그래서 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 만들어졌다.
    
    Mockito
    많은 인기를 끌고 있는 목 오브젝트 프레임워크
    간단한 메소드 호출만으로 다이나믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.
    사용법
        mock() : 목오브젝트 생성
        when() : ~할 때
        thenReturn(변수) : 변수로 리턴해라
        times() : 호출 횟수
        verify() : 확인하라
    단계
        1. 인터페이스를 이용해 목 오브젝트를 만든다.
        2. 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메서드가 호출되면 예외를 강제로 던지가 만들 수 있다.
        3. 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
        4. 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메서드가 호출 됐는지, 어떤 값을 가지고
           몇 번 호출됐는지를 검증한다.
    
#### 6-3 다이나믹 프록시와 팩토리 빈-1
###### 코드 추가
    1. ReflectionTest 추가
    2. Proxy Test 를 위한 Hello 인터페이스 와 타겟 HelloTarget, 프록시 HelloUppercase 추가
    3. InvocationHandler 구현 클래스 UppercaseHandler 추가
    4. UserServiceTx 를 다이나믹 프록시 방식으로 변경하기 위한 TransactionHandler 추가
    5. FactoryBean 인터페이스 구현을 위한 클래스 Message 추가
###### 정리
    자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을
    대리자, 대리인과 같은 역할을 한다고 해서 프록시라고 부른다.
    프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃 또는 실체라고 부른다.
    
    프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것
    프록시는 사용 목적에 따라 두 가지로 구분
    1. 클라이언트가 타깃에 접근하는 방법을 제어 - 프록시 패턴
    2. 타깃에 부가적인 기능을 부여 - 데코레이터 패턴
    
    데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
    코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않다.
    프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에
    자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.
    
    프록시 패턴은 타깃에 대한 접근 방법을 제어하려는 목적으로 사용한다.
    클라이언트가 타깃에 접근하는 방식을 변경
    타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우에는 
    꼭 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다.
    클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트를 만드는 대신
    프록시를 넘겨주는 것이다.
    그리고 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고
    요청을 위임하는 방식
    프록시 패턴의 타깃은 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용
    구조적으로 보자면 프록시와 데코레이터는 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃
    클래스 정보를 알고 있는 경우가 많다.
    
    다이나믹 프록시
    프록시를 만들기 위해서는 매번 새로운 클래스를 정의하고 인터페이스를 구현해야 하기 때문에
    상당히 번거로운 일이다.
    자바에서는 java.lang.reflect 패키지로 프록시를 손쉽게 만들 수 있도록 지원한다.
    
    리플렉션
    다이나믹프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
    리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든것이다.
    클래스 오브젝트를 이용하면 클래스 코드에 대한 메타정보를 가져오거나 오브젝트를 조작할 수 있다.
    클래스의 이름, 상속, 구현, 필드값, 타입, 메서드 정의, 파라미터, 리턴타입 등을 알아낼 수 있다.
    원하는 파라미터 값을 이용해 메서드를 호출하고 오브젝트의 필드값을 읽고 수정할 수 있다.
    
    다이나믹 프록시는 프록시 팩토리에 의해 런타임 시 다이나믹하게 만들어지는 오브젝트다.
    다이나믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 만들어진다.
    클라이언트는 다이나믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다.
    프록시를 만들 때 인터페이스를 모두 구현하지 않아도 된다.
    인터페이스 저보만 제공해주면 해당 구현 클래스 오브젝트를 자동으로 만들어 준다.
    
    InvocationHandler 인터페이스를 사용하여 구현
    구현한 클래스와 Proxy.newProxyInstance 를 이용하여 다이나믹 프록시 생성
    
    그러나 문제는 DI 의 대상이 되는 다이나믹 프록시 오브젝트는 일반적인 스프링의 빈으로는 등록할 수가 없다.
    스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해 해당 클래스의 오브젝트를 만든다.
    스프링은 내부적으로 리플렉션 API 를 이용해 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성
    다이나믹 프롣시 오브젝트의 클래스가 어떤 것인지도 알 수 없고, 
    클래스 자체도 내부적으로 다이나믹하게 새로 정의해서 사용
    
    팩토리 빈
    스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈
    FactoryBean 인터페이스를 구현
    FactoryBean 의 getObject 메서드가 생성해주는 오브젝트가 빈으로 등록된다.
    
#### 6-3 다이나믹 프록시와 팩토리 빈-2
###### 코드 추가
    1. Transaction Handler 를 이용하는 다이나믹 프록시 TxProxyFactoryBean 추가
###### 문제점
    프록시 팩토리 빈의 한계
    프록시를 통해 타깃에 부가기능을 제공하는 것은 메서드 단위의 일
    따라서 여러 개의 클래스에 부가 기능을 제공하는 것은 불가능하다.
    또한 하나의 타깃에 어려 개의 부가기능을 적용하는 것도 문제다.
    TransactionHandler 오브젝트가 프록시 팩티로 빈 개수만큼 만들어진다.
###### 정리
    프로퍼티의 타입이 Class 인 경우는 value 로 설정한 이름을 가진 Class 오브젝트로
    자동 변환해 줌
    
    데코레이터 패턴의 문제점은 프록시를 적용할 대상이 구현하고 있는 인터페이스를 구현하는
    프록시 클래스를 일일이 만들어줘야 하는점, 부가적인 기능이 여러 메서드에 반복적으로
    나타나게 돼서 코드 중복이 발생한다는 점이었다.
    
    다이나믹 프록시는 리플렉션을 이용하여 이 문제점들을 제거할 수 있다.
    
#### 6-4 스프링의 프록시 팩토리 빈-1
###### 정리
    스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공해준다.
    스프링의 ProxyFactoryBean 은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다.
    ProxyFactoryBean 은 프록시를 생성하는 작업만 담당하고, 부가기능은 MethodInterceptor 를 구현해서 만든다.
    MethodInterceptor 는 InvocationHandler 와 다르게 타깃 오브젝트에 대한 정보까지 함께 제공받는다.
    
    ProxyFactoryBean 에는 여러 개의 MethodInterceptor 를 추가할 수 있다.
    ProxyFactoryBean 하나로 여러 개의 부가기능을 제공해주는 프록시를 만들 수 있다는 뜻이다.
    
    MethodInterceptor 는 Advice 인터페이스를 상속하고 있는 서브 인터페이스 이다.
    타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트를 스프링에서는 어드바이스 라고 부른다.
    MethodInterceptor 는 InvocationHandler 와 다르게 구현할 인터페이스를 알려주지 않는다.
    인터페이스를 굳이 알려주지 않아도 ProxyFactoryBean 에 있는 "인터페이스 자동검출" 기능을 이용해
    타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아낸다.
    구현하는 인터페이스 중에서 일부만 프록시에 적용하길 원한다면 인터페이스 정보를 제공해도 된다.
    
    MehtodInterceptor 는 여러 프록시가 공유해서 사용할 수 있다.
    때문에 타깃 정보를 갖고 있지 않도록 만들었다.
    그래서 트랜잭션 적용 메서드 패턴은 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 MethodInterceptor 에
    특정 프록시만 적용되는 패턴을 넣으면 문제가 된다.
    
    그래서 스프링은 메서드 선정 알고리즘을 담은 클래스를 제공한다.
    포인트컷은 메서드 선정 알고리즘을 담은 오브젝트이다.
    프록시는 클라이언트로부터 요청을 받으면 먼저 포인트컷에게 부가기능을 부여할 메서드인지를 확인해달라고 요청한다.
    포인트컷이 필요 없을 때는 ProxyFactoryBean 의 addAdvice() 메서드를 호출해서 어드바이스만 등록하면 된다.
    어드바이스와 포인트컷을 묶은 오브젝트를 인터페이스 이름을 따서 어드바이저 라고 한다.
    
#### 6-4 스프링의 프록시 팩토리 빈-2
###### 코드 추가
    1. MethodInterceptor 구현체 TransactionAdvice 추가
    2. 구현한 TransactionAdvice 와 NameMatchMethodPointcut 을 이용하여 Advisor(DefaultPointcutAdvisor) DI 
###### 정리
    xml 스프링 환경설정 파일에서
    어드바이저는 interceptorNames 라는 프로퍼티를 통해 넣는다.
    어드바이스와 어드바이저를 혼합해서 설정할 수 있도록 property 태그 대신 list 와 value 태그를 통해
    여러 개의 값을 넣을 수 있또록 하고 있다.
    value 태그에는 어드바이스 또는 어드바이저로 설정한 빈의 아이디를 넣으면 된다.

#### 6-5 스프링 AOP-1
###### 문제점
    설정 정보에서 타깃 오브젝트가 추가 될때마다 다른 타깃 오브젝트에 같은 빈 클래스종류, 어드바이스, 포인트 컷을 등록해줘야함
###### 정리
    JDK 의 다이나믹 프록시는 특정 인터페이스를 구현한 오브젝트에 대해서 프록시 역할을 해주는 클래스를 "런타임" 시에 만들어준다.
    그 덕분에 개발자가 일일이 인터페이스 메서드를 구현하는 프록시 클래스를 만들어서 위임과 부가기능의 코드를
    중복해서 넣어주지 않아도 되었다.
    
    스프링이 DI 를 이용해 만들어지는 애플리케이션 코드가 OCP 에 충실할 수 있도록 한다면, 스프링 스스로도 그 가치를 따르는 게 마땅하다.
    스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분 외에는 대부분 확장할 수 있도록 확장 포인트를 제공한다.
    
    그 확장 포인트 중 BeanPostProcessor 인터페이스를 구현해서 만드는 빈 후처리기가 있다.
    빈 후처리기는 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준다.
    스프링이 제공하는 빈 후처리기 중 하나인 DefaultAdvisorAutoProxyCreator 는 어드바이저를 이용한 자동 프록시 생성기다.
    빈 후처리기를 스프링에 적용하는 방법은
    빈 후처리기 자체를 빈으로 등록하고, 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청,
    후처리 작업 후 생성된 프록시로 포장된 오브젝트를 컨테이너에 돌려준다.
    빈 후처리기는 빈 오브젝트의 프로퍼티를 강제로 수정할 수도 있고 별도의 초기화 작업을 수행할 수도 있다.
    심지어는 만들어진 빈 오브젝트 자체를 바꿔치기할 수 도 있다.
    
#### 1-1
###### 코드 추가
###### gradle 추가
###### 문제점
###### 정리


